---
title: "R Notebook"
output: html_notebook
---

```{r}
library(ggplot2)
library(tidyverse)
library(biomaRt)
library(clusterProfiler)
library(ReactomePA)
library(glmnet)
library(hdi)
library(stabs)
library(DESeq2)
library(limma)
library(pheatmap)
library(RColorBrewer)
```

```{r}
## In Rstudio, find the path to the directory where the current script is located.
## If not using Rstudio, current_dir should point to your working directory for this demo.
current_dir <- dirname(rstudioapi::getSourceEditorContext()$path)
```

```{r}
meta <- read.csv(paste0(current_dir,"/data/metadata/meta_RNAseq.csv"), row.names = 1) %>%
  # Batch as character
  mutate(Batch = as.character(Batch)) %>%
  # exclude controls
  dplyr::filter(!Luca_Lab_ID=="control") %>%
  # This sample was bad quality 
  dplyr::filter(!SampleID %in% c("GMCC1S1")) %>%
  # These samples were outliers amongst the RNAseq
  dplyr::filter(!SampleID %in% c("GMCC4S10", "GMCC3S7", "GMCC4C6", "GMCC5C5", "GMCC5C4", "GMCC5C3")) %>%
  # These samples were not used to treat the colonocytes
  dplyr::filter(!SampleName %in% c("1127XT", "1462QI", "3364PX", "3553XK", "3606IJ", "9423WC")) %>%
  # These samples did not have metagenomic sequencing data
  dplyr::filter(!SampleID %in% c("GMCC1S6", "GMCC2S3", "GMCC4S7")) %>%
  mutate(rn = SampleID) %>%
  column_to_rownames("rn") 
  #dplyr::filter(!SampleName=="4342XH")
meta <- meta[order(row.names(meta)), ]

meta_urban <- meta %>% dplyr::filter(urbanism=="urban")
meta_urban <- meta_urban[order(row.names(meta_urban)), ]

meta_rural <- meta %>% dplyr::filter(urbanism=="rural")
meta_rural <- meta_rural[order(row.names(meta_rural)), ]

```

```{r}
## load gene expression data
# samples are rows, genes are columns
#genes <- load_gene_expr(paste0(current_dir,"/input/gene_expresion_demo_sp_CCA.txt"))
genes <- read.csv(paste0(current_dir,"/results/docs/raw_read_cts_filt.csv"), row.names = 1)
genes <- genes[, colnames(genes) %in% meta$SampleID]
genes <- genes[, order(colnames(genes))] %>% t() %>% as.matrix() 

```

Perform batch correction

```{r}
genes_bc <- removeBatchEffect(t(genes), c(meta$Batch)) 
```

Apply variance stabilizing transformation from DESeq2

```{r}
dds <- DESeqDataSetFromMatrix(countData = t(genes), 
                              colData = meta, 
                              design = ~ 1) 

# Normalize the counts
dds <- estimateSizeFactors(dds)
normalized_counts <- counts(dds, normalized=TRUE)

vsd <- vst(dds, blind = FALSE)

normalized_counts_bc <- removeBatchEffect(normalized_counts, c(meta$Batch)) 
# set negative values to 0
normalized_counts_bc[normalized_counts_bc < 0] <- 0
# round the values to the nearest integer
normalized_counts_bc <- round(normalized_counts_bc)


dds_bc <- DESeqDataSetFromMatrix(countData = normalized_counts_bc, 
                                 colData = meta, 
                                 design = ~ 1)

vsd_bc <- vst(dds_bc, blind = FALSE)
vsd_mat <- assay(vsd_bc)

# Filter out genes with low variance using 25% quantile as cut-off for each disease cohort
# Assuming 'meta' contains a column 'disease_cohort' that specifies the disease cohort for each sample
# Adjust the column name 'disease_cohort' to the actual column name in your metadata

filtered_genes_list <- lapply(unique(meta$urbanism), function(cohort) {
  # Subset the transformed matrix and metadata for the current cohort
  cohort_samples <- meta %>% dplyr::filter(urbanism == cohort) %>% rownames()
  cohort_vsd_mat <- vsd_mat[, cohort_samples]
  
  # Calculate variance for each gene in the current cohort
  gene_variances <- apply(cohort_vsd_mat, 1, var)
  
  # Determine the 25% quantile of variance
  variance_cutoff <- quantile(gene_variances, 0.25)
  
  # Filter genes with variance above the 25% quantile
  filtered_genes <- rownames(cohort_vsd_mat)[gene_variances > variance_cutoff]
  
  return(filtered_genes)
})

# Combine the filtered gene lists from each cohort
filtered_genes <- unique(unlist(filtered_genes_list))

# Subset the transformed matrix to include only the filtered genes
genes_bc_vst_varfilt <- vsd_mat[filtered_genes, ]

# Check the dimensions of the filtered matrix
dim(genes_bc_vst_varfilt)

genes_bc_vst_varfilt <- t(genes_bc_vst_varfilt)
```

```{r}
plotPCA(vsd, intgroup = "Batch")
plotPCA(vsd_bc, intgroup = "Batch")
```

```{r}
genes_urban <- genes_bc_vst_varfilt[rownames(genes_bc_vst_varfilt) %in% meta_urban$SampleID, ]
genes_urban <- genes_urban[order(rownames(genes_urban)),]

genes_rural <- genes_bc_vst_varfilt[rownames(genes_bc_vst_varfilt) %in% meta_rural$SampleID, ]
genes_rural <- genes_rural[order(rownames(genes_rural)),]
```

```{r}
## load microbiome data
# samples are rows, individual taxa are columns
# column names are like this: 
# Bacteria;Bacteroidetes;Bacteroidia;Bacteroidales;Prevotellaceae

#microbes <- load_microbiome_abnd(paste0(current_dir,"/input/microbiome_demo_sp_CCA.txt"))
microbes <- read.csv(paste0(current_dir,"/results/docs/clr_filt_microbe_abundances.csv")) %>%
  dplyr::rename("SampleName"=X) %>%
  left_join(meta[c("SampleName", "SampleID")],by="SampleName") %>%
  dplyr::filter(SampleID %in% meta$SampleID) %>%
  dplyr::select(-SampleName) %>%
  column_to_rownames("SampleID") %>%
  as.matrix()
microbes <- microbes[order(rownames(microbes)),] 
```
```{r}
update2 <- tibble(
  oldTaxonomy = c("Roseburia_sp_1", "Coprococcus_sp_2"),
  phylum = c("p__Firmicutes_A", "p__Bacillota_A"),
  class = c("c__Clostridia", "c__Clostridia"),
  order = c("o__Lachnospirales", "o__Lachnospirales"),
  family = c("f__Lachnospiraceae", "f__Lachnospiraceae"),
  genus=c("g__RUG115", "g__Bariatricus"),
  species=c("s__RUG115 sp900066395", "s__Bariatricus sp934320645")
)
taxonomy_names_updated <- read.csv("data/metaG-taxonomy/taxonomic_names_updates.tsv", sep="\t", header=T) %>%
  bind_rows(update2) %>%
  # 1) Remove the prefix (p_, c_, o_, f_, g_, s_)
  mutate(across(everything(), ~ gsub("^[pcofgs]?_", "", .))) %>%
  # 2) Remove any leading underscore
  mutate(across(everything(), ~ gsub("^_", "", .))) %>%
  # 3) Replace spaces with underscores in the species column
  mutate(species = if("species" %in% names(.)) gsub(" ", "_", species) else species) %>%
  # 4) Rename the columns to just the first letter of the current name
  rename_with(~ substr(., 1, 1), -1) %>%
  mutate(across(everything(), ~ ifelse(. == "" | . == "_", NA, .))) %>%
  #column_to_rownames("oldTaxonomy") %>%
  mutate(d = NA, k = NA) %>%
  dplyr::select(d,k,p,c,o,f,g,s, everything()) %>%
  {rownames(.) <- gsub("\\.", "", rownames(.)); .}

head(taxonomy_names_updated)
```
```{r}
microbes_urban <- microbes[rownames(microbes) %in% meta_urban$SampleID, ]
microbes_urban <- microbes_urban[order(rownames(microbes_urban)),]

microbes_rural <- microbes[rownames(microbes) %in% meta_rural$SampleID, ]
microbes_rural <- microbes_rural[order(rownames(microbes_rural)),]
```




Combine covariates with microbes

```{r}
covariates <- meta %>%
  dplyr::select(SampleName, SampleID, country, age, sex)
covariates <- covariates[order(rownames(covariates)),] 

# Impute missing values for USA samples
# I IMPUTED THESE IN THE 02 MARKDOWN DOC BASED ON MICROBIOME PCS 1-5
imputed_samples <- data.frame(
  SampleName = c("FMG110", "FMG111", "FMG112", "FMG28", "FMG65"),
  age = c(29,59,39,29,39),
  sex= c("F","M","F","M","M")
)

covariates_imputed <- covariates
rownames(covariates_imputed) <- NULL

covariates_imputed$age[covariates_imputed$SampleName %in% imputed_samples$SampleName] <- imputed_samples$age
covariates_imputed$age <- as.numeric(covariates_imputed$age)
covariates_imputed$sex[covariates_imputed$SampleName %in% imputed_samples$SampleName] <- imputed_samples$sex

# Convert categorical variables to factors
covariates_imputed <- covariates_imputed %>%
  dplyr::select(-SampleName) %>%
  mutate(country = factor(country),
         sex = factor(sex)) %>%
  column_to_rownames("SampleID")

# Dummy encode the factors using model.matrix
covariates_imputed_ohe <- as.data.frame(model.matrix(~ country + sex - 1, data = covariates_imputed))

# Filter for urban and rural
covariates_imputed_ohe_urban <- microbes[rownames(covariates_imputed_ohe) %in% meta_urban$SampleID, ]
covariates_imputed_ohe_rural <- microbes[rownames(covariates_imputed_ohe) %in% meta_rural$SampleID, ]

# Join with microbe matrix
microbes_covariates <- cbind(microbes, covariates_imputed_ohe) %>% as.matrix()
microbes_covariates_urban <- cbind(microbes_urban, covariates_imputed_ohe_urban) %>% as.matrix()
microbes_covariates_rural <- cbind(microbes_rural, covariates_imputed_ohe_rural) %>% as.matrix()

## Ensure same samples in both genes and microbes data
stopifnot(all(rownames(genes) == rownames(microbes_covariates)))
```

```{r}
y <- genes_bc #genes_bc_vst_varfilt #response
x <- microbes_covariates #microbes_covariates #predictors

x.uniq <- unique(x, MARGIN = 2)
dim(x.uniq)
x <- x.uniq

print(paste0("# genes = ",dim(y)[2]))

print(paste0("# microbes = ",dim(x)[2]))
```

```{r}
############### Functions ############

estimate.sigma <- function(x, y_i, bestlambda, tol) {
  
  lasso.fit = glmnet(x,y_i,alpha = 1)
  # beta <- coef(lasso.fit, s = bestlambda)[-1] ## This gives coefficients of fitted model, not predicted coeff. 
  # try(if(length(which(abs(beta) > tol)) > n) stop(" selected predictors more than number of samples! Abort function"))
  
  y = as.vector(y_i)
  yhat = as.vector(predict(lasso.fit, newx = x, s = bestlambda))
  beta = predict(lasso.fit,s=bestlambda, type="coef") ## predicted coefficients
  df = sum(abs(beta) > tol) ## Number of non-zero coeff. Floating-point precision/tolerance used instead of checking !=0
  n = length(y_i)
  ss_res = sum((y - yhat)^2)
  
  if((n-df-1) >= 1) {
    sigma = sqrt(ss_res / (n-df-1)) ## note, if we get rid of intercept when extracting beta, so should be drop -1?
    sigma.flag = 0
  } else{
    
    sigmas <- numeric()
    ## Repeat 5x and take median of finite values else assign sigma to ss_res and raise the flag 
    for( j in 1:5){
      bestlambda = get.lambda(x, y_i, 10, 10)
      lasso.fit = glmnet(x,y_i,alpha = 1)
      y = as.vector(y_i)
      yhat = as.vector(predict(lasso.fit, newx = x, s = bestlambda))
      beta = predict(lasso.fit,s=bestlambda, type="coef") ## predicted coefficients
      df = sum(abs(beta) > tol) ## Number of non-zero coeff. Floating-point precision/tolerance used instead of checking !=0
      n = length(y_i)
      ss_res = sum((y - yhat)^2)
      if((n-df-1) >= 1) {
        sigmas[j] = sqrt(ss_res / (n-df-1)) ## note, if we get rid of intercept when extracting beta, so should be drop -1?
      }
    }
    if(length(sigmas != 0 )){
      
      sigma = median(sigmas, na.rm = T)
      sigma.flag = 1
    } else{
      sigma = 1 ## conservative option
      # sigma = ss_res ## lenient option
      sigma.flag = 2
    }
    
  }
  
  return(list(sigmahat = sigma, sigmaflag = sigma.flag, betahat = beta)) ## we return beta to be used later in hdi function.
  
}

## Inspired from the details for estimateSigma() function in selectiveInference package: https://cran.r-project.org/web/packages/selectiveInference/selectiveInference.pdf
estimate.sigma.loocv <- function(x, y_i, bestlambda, tol) {
  
  lasso.fit = glmnet(x,y_i,alpha = 1)
  # beta <- coef(lasso.fit, s = bestlambda)[-1] ## This gives coefficients of fitted model, not predicted coeff. 
  # try(if(length(which(abs(beta) > tol)) > n) stop(" selected predictors more than number of samples! Abort function"))
  
  y = as.vector(y_i)
  yhat = as.vector(predict(lasso.fit, newx = x, s = bestlambda))
  beta = predict(lasso.fit,s=bestlambda, type="coef") ## predicted coefficients
  df = sum(abs(beta) > tol) ## Number of non-zero coeff. Floating-point precision/tolerance used instead of checking !=0
  n = length(y_i)
  ss_res = sum((y - yhat)^2)
  
  if((n-df-1) >= 1) {
    sigma = sqrt(ss_res / (n-df-1)) ## note, if we get rid of intercept when extracting beta, so should be drop -1?
    sigma.flag = 0
  } else{
      sigma = 1 ## conservative option
      # sigma = ss_res ## lenient option
      sigma.flag = 2
    }
    
  
  return(list(sigmahat = sigma, sigmaflag = sigma.flag, betahat = beta)) ## we return beta to be used later in hdi function.
  
}


fit.cv.lasso <- function(x, y_i, kfold, repeats){
  
  lambdas = NULL
  r.sqr.final <- numeric()
  r.sqr.final.adj <- numeric()
  r.sqr.CV.test <- numeric()
  lasso.cv.list <- list()
  
  for (i in 1:repeats){
    
      ## glmnet CV
      fit <- cv.glmnet(x, y_i, alpha=1, nfolds=kfold, type.measure = "mse", keep =TRUE, grouped=FALSE)  
      errors = data.frame(fit$lambda,fit$cvm)
      lambdas <- rbind(lambdas,errors)
      
      ## Get R^2 of final model
      r.sqr.final[i] <- r_squared(as.vector(y_i), 
                                  as.vector(predict(fit$glmnet.fit, 
                                                    newx = x, s = fit$lambda.min)))
      ## Get adjusted R^2
      r.sqr.final.adj[i] <- adj_r_squared(r.sqr.final[i], n = nrow(x), 
                                          p = sum(as.vector(coef(fit$glmnet.fit, 
                                                                 s = fit$lambda.min)) > 0))
      
  }
  
  # take mean cvm for each lambda
  lambdas <- aggregate(lambdas[, 2], list(lambdas$fit.lambda), mean)
  # dim(lambdas)
  # select the best one
  bestindex = which(lambdas[2]==min(lambdas[2]))
  bestlambda = lambdas[bestindex,1]
  
  return(list(bestlambda = bestlambda, r.sqr = median(r.sqr.final), 
              r.sqr.adj = median(r.sqr.final.adj)
              ))
}

## functions to compute R2
## Adapted from https://rpubs.com/kaz_yos/alasso
r_squared <- function(y, yhat) {
  ybar <- mean(y)
  ## Total SS
  ss_tot <- sum((y - ybar)^2)
  ## Residual SS
  ss_res <- sum((y - yhat)^2)
  ## R^2 = 1 - ss_res/ ss_tot
  1 - (ss_res / ss_tot)
}
## Function for Adjusted R^2
## n sample size, p number of prameters
adj_r_squared <- function(r_squared, n, p) {
  1 - (1 - r_squared) * (n - 1) / (n - p - 1)
}

############### Estimate sigma (standard deviation of the error term or noise) ###############

estimate.sigma.fit.hdi <- function(x, y, gene_name){
  ## Import all the libraries for the current node/core on MSI 
  check.packages <- function(pkg){
    new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
    if (length(new.pkg)) 
      install.packages(new.pkg, dependencies = TRUE, repos = "http://cran.us.r-project.org")
    sapply(pkg, require, character.only = TRUE)
  }
  
  packages <- c("glmnet","hdi","methods","doParallel") ## package methods is not loaded by default by RScript on MSI 
  check.packages(packages)
  
  print(paste0("Processing gene:", gene_name));flush.console()
  
  ## Extract the expression for this gene (response variable)
  y_i <- y[,grep(paste0("^",gene_name,"$"),colnames(y))]
  
  ## Make sure y_i is numeric before model fitting 
  #stopifnot(class(y_i) == "numeric") SABRINA REMOVED THIS BC VALUES ARE INTEGERS
  
  ## Fit lasso CV model
  fit.model <- fit.cv.lasso(x, y_i,  kfold = length(y_i), repeats = 1)
  bestlambda <- fit.model$bestlambda
  r.sqr <- fit.model$r.sqr
  r.sqr.adj <- fit.model$r.sqr.adj
 
  ## Estimate sigma using the estimated lambda param
  sigma.myfun <- estimate.sigma.loocv(x, y_i, bestlambda, tol=1e-4)
  sigma <- sigma.myfun$sigmahat
  beta <- as.vector(sigma.myfun$betahat)[-1]
  sigma.flag <- sigma.myfun$sigmaflag
  
  ## Inference 
  lasso.proj.fit <- lasso.proj(x, y_i, multiplecorr.method = "BH", betainit = beta, sigma = sigma, suppress.grouptesting = T)
  lasso.ci <- as.data.frame(confint(lasso.proj.fit, level = 0.95))
  lasso.FDR.df <- data.frame(gene = rep(gene_name, length(lasso.proj.fit$pval)), 
                             taxa = names(lasso.proj.fit$pval.corr), 
                             r.sqr = r.sqr, r.sqr.adj = r.sqr.adj,
                             pval = lasso.proj.fit$pval, padj = lasso.proj.fit$pval.corr, 
                             ci.lower = lasso.ci$lower, ci.upper = lasso.ci$upper,
                             sigma = sigma, sigma.flag = sigma.flag,
                             row.names=NULL)
  
 
  return(lasso.FDR.df)
  
}
```

Save everything as a big R object so we can run on midway

```{r}
input.genes.list <- colnames(y)

lasso_obj_test <- list( 
  # functions
  estimate.sigma,
  estimate.sigma.loocv,
  fit.cv.lasso,
  r_squared,
  adj_r_squared,
  estimate.sigma.fit.hdi,
  # variables
  y[,1:10],
  x[,1:10],
  input.genes.list[1:10]
  )
names(lasso_obj_test) <- c(  # functions
  "estimate.sigma",
  "estimate.sigma.loocv",
  "fit.cv.lasso",
  "r_squared",
  "adj_r_squared",
  "estimate.sigma.fit.hdi",
  # variables
  "y",
  "x",
  "input.genes.list")

saveRDS(lasso_obj_test, "data/for_hpc/lasso_obj_test.rds")
```

Import after running lasso and stability selection.

```{r}
# lasso results
lasso_all <- read.table("results/docs/lasso/microbe/lasso_hdi_all.txt")
lasso_urban <- read.table("results/docs/lasso/microbe/lasso_hdi_urban.txt")
lasso_rural <- read.table("results/docs/lasso/microbe/lasso_hdi_rural.txt")

# stability selection
ss_all <- read.table("results/docs/lasso/microbe/stabs_stabsel_output_all.txt")
ss_urban <- read.table("results/docs/lasso/microbe/stabs_stabsel_output_urban.txt")
ss_rural <- read.table("results/docs/lasso/microbe/stabs_stabsel_output_rural.txt")
```
Update taxa names
```{r}
# Update ss_all
ss_all <- ss_all %>%
  left_join(taxonomy_names_updated[,c("s", "oldTaxonomy")], by = c("taxa.selected" = "oldTaxonomy")) %>%
  mutate(taxa.selected = ifelse(is.na(s), taxa.selected, s)) %>%
   dplyr::select(-s)

ss_urban <- ss_urban %>%
  left_join(taxonomy_names_updated[,c("s", "oldTaxonomy")], by = c("taxa.selected" = "oldTaxonomy")) %>%
  mutate(taxa.selected = ifelse(is.na(s), taxa.selected, s)) %>%
   dplyr::select(-s)

ss_rural <- ss_rural %>%
  left_join(taxonomy_names_updated[,c("s", "oldTaxonomy")], by = c("taxa.selected" = "oldTaxonomy")) %>%
  mutate(taxa.selected = ifelse(is.na(s), taxa.selected, s)) %>%
   dplyr::select(-s)
```
```{r}
# Update lasso_all
lasso_all <- lasso_all %>%
  left_join(taxonomy_names_updated[,c("s", "oldTaxonomy")], by = c("taxa" = "oldTaxonomy")) %>%
  mutate(taxa = ifelse(is.na(s), taxa, s)) %>%
   dplyr::select(-s)

lasso_urban <- lasso_urban %>%
  left_join(taxonomy_names_updated[,c("s", "oldTaxonomy")], by = c("taxa" = "oldTaxonomy")) %>%
  mutate(taxa = ifelse(is.na(s), taxa, s)) %>%
   dplyr::select(-s)

lasso_rural <- lasso_rural %>%
  left_join(taxonomy_names_updated[,c("s", "oldTaxonomy")], by = c("taxa" = "oldTaxonomy")) %>%
  mutate(taxa = ifelse(is.na(s), taxa, s)) %>%
   dplyr::select(-s)

```



```{r}
lasso_all <- lasso_all %>%
  mutate(beta_est = (ci.lower + ci.upper) / 2)
lasso_urban <- lasso_urban %>%
  mutate(beta_est = (ci.lower + ci.upper) / 2)
lasso_rural <- lasso_rural %>%
  mutate(beta_est = (ci.lower + ci.upper) / 2)
```

```{r}
head(lasso_all)
head(ss_all)
```

```{r}
ss_overlap <- function(lasso_df, ss_df) {
  ss_select <- ss_df %>% 
  dplyr::filter(!taxa.selected=="None") %>% 
  dplyr::rename("gene" = "gene_name") %>% 
  dplyr::rename("taxa" = "taxa.selected")
overlap <- merge(lasso_df, ss_select, by = c("gene","taxa")) %>%
  dplyr::filter(!taxa %in% c("sexM", 
                         "sexF", 
                         "countryGhana",
                         "countryRwanda",
                         "countryNigeria",
                         "countryMalaysia",
                         "countryUSA" )) %>%
  mutate(gene_taxa = paste(gene, taxa, sep=":")) %>%
  dplyr::filter(padj < 0.1)
return(overlap)
}

ss_select_all <- ss_overlap(lasso_all, ss_all)
ss_select_urban <- ss_overlap(lasso_urban, ss_urban)
ss_select_rural <- ss_overlap(lasso_rural, ss_rural)

length(unique(c(ss_select_urban$taxa, ss_select_rural$taxa)))

nrow(ss_select_all)
nrow(ss_select_urban)
nrow(ss_select_rural)
```

```{r}
summary_ss_select_all <- ss_select_all %>%
  group_by(taxa) %>%
  summarize(
    num_genes = n(),
    genes = paste(gene, collapse = ";")
  ) %>%
  arrange(desc(num_genes))
#write.csv(summary_ss_select_all, "results/docs/summary_ss_select_all.csv")

library(clipr)
write_clip(summary_ss_select_all)

genesummary_ss_select_all <- ss_select_all %>%
  group_by(gene) %>%
  summarize(num_taxa = n()) %>%
  arrange(desc(num_taxa))

summary_ss_select_urban <- ss_select_urban %>%
  group_by(taxa) %>%
  summarize(
    num_genes = n(),
    genes = paste(genes, collapse = ";")
  ) %>%
  arrange(desc(num_genes))
#write.csv(summary_ss_select_urban, "results/docs/summary_ss_select_urban.csv")

genesummary_ss_select_urban <- ss_select_urban %>%
  group_by(gene) %>%
  summarize(num_taxa = n()) %>%
  arrange(desc(num_taxa))

summary_ss_select_rural <- ss_select_rural %>%
  group_by(taxa) %>%
  summarize(num_genes = n()) %>%
  arrange(desc(num_genes))
#write.csv(summary_ss_select_rural, "results/docs/summary_ss_select_rural.csv")

genesummary_ss_select_rural <- ss_select_rural %>%
  group_by(gene) %>%
  summarize(num_taxa = n()) %>%
  arrange(desc(num_taxa))

union_sigtaxa <- unique(c(summary_ss_select_urban$taxa, summary_ss_select_rural$taxa))
union_siggenes <- unique(c(ss_select_urban$gene, ss_select_rural$gene))

union_sigtaxa <- unique(c(summary_ss_select_urban$taxa, summary_ss_select_rural$taxa))

# THIS IS A SHORTCUT BUT BRING DOWN UNION TO SPECIES ONLY BY SELECTING TAXA WITH UNDERSCORE
# NOT SUPER CORRECT NEED TO FIX LATER
#union_sigtaxa_s <- grep("_", union_sigtaxa, value = TRUE)

# Import the genus and species with a relative abundance > 0.1% after filtering
genus001 <- read.csv("results/docs/genus001.csv")
species001 <- read.csv("results/docs/species001.csv")

union_sigtaxa_s <- union_sigtaxa[union_sigtaxa %in% as.list(union(genus001$taxa, species001$taxa))]

ss_select_urban_s <- ss_select_urban %>%
  dplyr::filter(taxa %in% union_sigtaxa_s) %>%
  dplyr::filter(abs(beta_est) > 0.02)
ss_select_rural_s <- ss_select_rural %>%
  dplyr::filter(taxa %in% union_sigtaxa_s) %>%
  dplyr::filter(abs(beta_est) > 0.02)

union_sigtaxa_s <- unique(c(ss_select_urban_s$taxa, ss_select_urban_s$taxa))
union_siggenes_s <- unique(c(ss_select_urban_s$gene, ss_select_rural_s$gene))

```
```{r}
summary_ss_select_all_highabun <- summary_ss_select_all %>%
  dplyr::filter(taxa %in% unlist(union(genus001, species001)))
```
See unique associations
```{r}
unique_taxa_summary <- merge(
  summary_ss_select_urban[, c("taxa", "num_genes")],
  summary_ss_select_rural[, c("taxa", "num_genes")],
  by = "taxa", all = TRUE, suffixes = c("_urban", "_rural")
)

unique_taxa_summary_monoassociation <- subset(
  unique_taxa_summary,
  (num_genes_urban > 0 & is.na(num_genes_rural)) |
  (is.na(num_genes_urban) & num_genes_rural > 0)
)


# Urban-only taxa
urban_only <- subset(unique_taxa_summary_monoassociation, num_genes_urban > 0)
urban_pct_over_2 <- mean(urban_only$num_genes_urban > 3, na.rm = TRUE) * 100

# Rural-only taxa
rural_only <- subset(unique_taxa_summary_monoassociation, num_genes_rural > 0)
rural_pct_over_2 <- mean(rural_only$num_genes_rural > 3, na.rm = TRUE) * 100

# Show results
cat("Urban: ", round(urban_pct_over_2, 1), "% of unique taxa affect > 3 genes\n")
cat("Rural: ", round(rural_pct_over_2, 1), "% of unique taxa affect > 3 genes\n")

```
plot
```{r}
ggplot(unique_taxa_summary, aes(x=num_genes_urban)) + geom_histogram(stat="count")
ggplot(unique_taxa_summary, aes(x=num_genes_rural)) + geom_histogram(stat="count")
```


Compare lasso results to differential abundance results
```{r}
glm_results_urbanism <- readRDS("results/rds/glm_results_urbanism.rds")

# Define the function
join_num_genes <- function(glm_results_urbanism, summary_ss_select_all) {
  
  # Iterate over each dataframe in the nested list
  glm_results_urbanism2 <- lapply(names(glm_results_urbanism), function(level_name) {
    
    df <- glm_results_urbanism[[level_name]]  # Extract the dataframe
    
    # Ensure the corresponding column exists in df
    if (!(level_name %in% colnames(df))) {
      stop(paste("Column", level_name, "not found in dataframe"))
    }
    
    # Perform a left_join using the matching column
    df <- df %>%
      left_join(summary_ss_select_all, by = setNames("taxa", level_name)) %>%
      mutate(taxa = .data[[level_name]],
             num_genes = ifelse(is.na(num_genes), 0, num_genes),
             has_genes = ifelse(num_genes > 0, 1, 0))  # Binarize column
    
    return(df)
  })
  
  
  # Return named list
  names(glm_results_urbanism2) <- names(glm_results_urbanism)
  return(glm_results_urbanism2)
}



glm_results_urbanism_df <- glm_results_urbanism %>%
  map(~ {
    df <- .
    colnames(df)[1] <- "taxa"  # Rename the first column to "taxa"
    df
  }) %>%
  bind_rows(.id = "level")

summary_ss_select_all_DA <- summary_ss_select_all %>%
      left_join(glm_results_urbanism_df, by = "taxa") 
summary_ss_select_all_DA_filt <- summary_ss_select_all_DA %>%
      dplyr::filter(pval.holm<0.1) 


# Usage:
glm_results_urbanism_lasso_all <- join_num_genes(glm_results_urbanism, summary_ss_select_all)
glm_results_urbanism_lasso_urban <- join_num_genes(glm_results_urbanism, summary_ss_select_urban)
glm_results_urbanism_lasso_rural <- join_num_genes(glm_results_urbanism, summary_ss_select_rural)
```



```{r}
summary_ss_select_all_DA_plot <- summary_ss_select_all_DA %>%
  dplyr::mutate(lab=case_when(pval.holm < 0.1 ~ enriched_in,
                              pval.holm > 0 ~ NA)) %>%
  dplyr::arrange(desc(num_genes)) %>%
  #slice_head(n = 40) %>%
  dplyr::arrange(num_genes)

summary_ss_select_all_DA_plot$taxa <- factor(
  summary_ss_select_all_DA_plot$taxa,
  levels = summary_ss_select_all_DA_plot$taxa
)


# Offset value to position the tile just left of the bars
annotation_offset <- -2.2  # negative x value so it's left of the bars

# Create the annotated barplot
ggplot(summary_ss_select_all_DA_plot, aes(y = taxa)) +

  # Color annotation strip *before* the bar, close to axis
  geom_tile(aes(x = annotation_offset, fill = lab), 
            width = 1.5, height = 0.9) +
  scale_fill_manual(values=c("#7B2BC1","#6FBD8B"), na.value = "transparent",
                    name = "Differential abundance: Enriched in") +

  # Main barplot
  geom_bar(aes(x = num_genes), stat = "identity", fill = "grey70", width = 0.8) +
  theme_linedraw() +
  ggtitle("# Associations of taxa and host genes: ALL microbiomes") +
  labs(
  x = "Number of host genes",
  y = "Taxa"
)

ggsave("results/figs/RNAseq-metaG-microbe-Lasso/all_barplot.pdf", width=12, height=20)

```








```{r}
library(ggrepel)

# Define the function
plot_volcano <- function(df, label_threshold = 0.1) {
  
  # Create the volcano plot
  p <- ggplot(df, aes(x = effect, y = -log10(pval.holm))) +
    
    # Horizontal line at y = 0.1
    geom_hline(yintercept = label_threshold, linetype = "dotted", color = "lightgrey") +
    
    # Points: grey if below the line or has_genes == 0, black fill if has_genes == 1
    geom_point(aes(size = ifelse(-log10(pval.holm) > label_threshold, num_genes, 1),
                   fill = ifelse(has_genes == 1, "black", ifelse(-log10(pval.holm) > label_threshold, "above", "below"))),
               shape = 21, color = "black") +  # Set outline to black
    
    # Label taxa using geom_text_repel for points with higher p-values
    geom_text_repel(data = subset(df, -log10(pval.holm) > label_threshold & num_genes > 0),
                    aes(label = taxa),
                    size = 3) +
    
    # Customize fill scale
    scale_fill_manual(values = c("below" = "lightgrey", "above" = "grey", "black" = "black"), guide = "none") +
    
    # Customize size range for points
    scale_size_continuous(range = c(1, 10), limits = c(0, max(df$num_genes)), guide = "none") + #, guide = "none"
    
    # Labels and theme
    labs(x = "Absolute Effect Size (Differential Abundance)", y = "-log10(p-value)") +
    theme_minimal()
  
  return(p)
}

```

```{r}
plot_volcano(glm_results_urbanism_lasso_all[["s"]])
plot_volcano(glm_results_urbanism_lasso_urban[["s"]])
plot_volcano(glm_results_urbanism_lasso_rural[["s"]])
```

```{r}
plot_volcano(glm_results_urbanism_lasso_all[["g"]])
plot_volcano(glm_results_urbanism_lasso_urban[["g"]])
plot_volcano(glm_results_urbanism_lasso_rural[["g"]])
```

```{r}
plot_volcano(glm_results_urbanism_lasso_all[["f"]])
plot_volcano(glm_results_urbanism_lasso_urban[["f"]])
plot_volcano(glm_results_urbanism_lasso_rural[["f"]])
```
```{r}
library(ggpubr)  # For stat_cor
library(broom)   # For extracting regression stats

plot_volcano2 <- function(df, label_threshold = 0.1) {

  # Apply log transformation to num_genes (add 1 to avoid log(0))
  df$log_num_genes <- log(df$num_genes + 1)
  
  # Fit a linear model: abs(effect) ~ log(num_genes)
  lm_fit <- lm(abs(effect) ~ log_num_genes, data = df)
  lm_stats <- broom::glance(lm_fit)  # Extract statistics
  
  # Extract regression values
  r2_value <- lm_stats$r.squared
  p_value <- lm_stats$p.value
  
  # Create the volcano plot
  p <- ggplot(df, aes(x = log_num_genes, y = abs(effect))) +
    
    # Scatter plot points
    geom_point(aes(size = num_genes, fill = -log10(pval.holm)), 
               shape = 21, color = "black") +
    
    # Regression line
    geom_smooth(method = "lm", color = "blue", se = TRUE) +
    
    # Regression stats annotation
    annotate("text", x = max(df$log_num_genes) * 0.7, y = max(abs(df$effect)) * 0.9, 
             label = sprintf("RÂ² = %.2f\np = %.3g", r2_value, p_value), 
             size = 4, hjust = 0, color = "blue") +
    
    # Label taxa for high effect sizes or gene counts
    geom_text_repel(data = subset(df, effect > 0.9 | num_genes > 10), 
                    aes(label = taxa), size = 2) +
    
    # Customize fill scale
    scale_fill_gradient(low = "white", high = "red") +
    
    scale_size_continuous() +
    
    # Labels and theme
    labs(x = "Log(Number of Host Genes associated with Microbe)", 
         y = "Absolute Effect Size (Differential Abundance)") +
    theme_linedraw()

  return(p)
}


```
```{r}
plot_volcano(glm_results_urbanism_lasso_all[["s"]])
plot_volcano(glm_results_urbanism_lasso_urban[["s"]])
plot_volcano(glm_results_urbanism_lasso_rural[["s"]])
```
```{r}
plot_volcano2(glm_results_urbanism_lasso_all[["s"]])
plot_volcano2(glm_results_urbanism_lasso_urban[["s"]])
plot_volcano2(glm_results_urbanism_lasso_rural[["s"]])
```


```{r}
library(msigdbr)

#msigdbr_collections()

# download databases of interest
msigdb_h = msigdbr(species = "human", category = "H")
msigdb_cpPID = msigdbr(species = "human", category = "C2", subcategory = "CP:PID")
msigdb_cpKEGG = msigdbr(species = "human", category = "C2", subcategory = "CP:KEGG")
msigdb_cpREACTOME = msigdbr(species = "human", category = "C2", subcategory = "CP:REACTOME")
msigdb_cpBIOCARTA = msigdbr(species = "human", category = "C2", subcategory = "CP:BIOCARTA")
msigdb_cgp = msigdbr(species = "human", category = "C2", subcategory = "CGP") %>%
  mutate(gs_name = paste("CGP", gs_name, sep = "_"))
msigdb_cgn = msigdbr(species = "human", category = "C4", subcategory = "CGN") %>%
  mutate(gs_name = paste("CGN", gs_name, sep = "_"))
msigdb_cm = msigdbr(species = "human", category = "C4", subcategory = "CM") %>%
  mutate(gs_name = paste("CM", gs_name, sep = "_"))
msigdb_IMMUNESIGDB = msigdbr(species = "human", category = "C7", subcategory = "IMMUNESIGDB") %>%
  mutate(gs_name = paste("IMMUNESIGDB", gs_name, sep = "_"))

# Experimenting with pasting these all together to reduce code burden
msigdb_cp <- rbind(msigdb_cpKEGG, msigdb_cpREACTOME) %>%
  rbind(msigdb_cpPID)

msigdb_all <- rbind(msigdb_cpKEGG, msigdb_cpREACTOME) %>% #, msigdb_cpREACTOME
  rbind(msigdb_cpPID) %>%
  rbind(msigdb_cpBIOCARTA) %>%
  rbind(msigdb_h) #%>%
  #rbind(msigdb_cgp) %>%
  #rbind(msigdb_cgn) %>%
  #rbind(msigdb_cm)  %>%
  #rbind(msigdb_IMMUNESIGDB)
  
# Summarize metrics from all pathways from all databases
msigdb_cp_summary <- msigdb_cp %>%
  group_by(gs_name) %>%
  summarize(GeneCount = n_distinct(gene_symbol)) %>%
  # sambhawas filtering cutoffs
  dplyr::filter(GeneCount > 25, GeneCount < 300)

msigdb_all_summary <- msigdb_all %>%
  group_by(gs_name) %>%
  summarize(GeneCount = n_distinct(gene_symbol)) %>%
  # sambhawas filtering cutoffs
  dplyr::filter(GeneCount > 25, GeneCount < 300)

# Narrow down pathways that meet our thresholds  
msigdb_cp_filt <- msigdb_cp %>%
  dplyr::filter(gs_name %in% msigdb_cp_summary$gs_name)
msigdb_cpPID_filt <- msigdb_cpPID %>%
  dplyr::filter(gs_name %in% msigdb_cp_summary$gs_name)
msigdb_cpKEGG_filt <- msigdb_cpKEGG %>%
  dplyr::filter(gs_name %in% msigdb_cp_summary$gs_name)
msigdb_cpREACTOME_filt <- msigdb_cpREACTOME %>%
  dplyr::filter(gs_name %in% msigdb_cp_summary$gs_name)
msigdb_cpBIOCARTA_filt <- msigdb_cpBIOCARTA %>%
  dplyr::filter(gs_name %in% msigdb_cp_summary$gs_name)

msigdb_all_filt <- msigdb_all %>%
  dplyr::filter(gs_name %in% msigdb_all_summary$gs_name)
```
```{r}
msigdb_cp_t2g = msigdb_all_filt %>% dplyr::distinct(gs_name, gene_symbol) %>% as.data.frame()

```
```{r}
annotate_ensembl_symbol2ensembl <- function(ensembl_ids) {
  ensembl = useEnsembl(biomart = "ensembl", dataset = "hsapiens_gene_ensembl")#, host = "jul2023.archive.ensembl.org") #, host = "jul2023.archive.ensembl.org"

  # Define annotations
  att_interest <- c("ensembl_gene_id", "uniprot_gn_symbol") #, "uniprot_gn_id", "entrezgene_id"

  # Annotate
  annotated_data <- biomaRt::getBM(
    attributes = att_interest,
    filters = "uniprot_gn_symbol",
    values = ensembl_ids,
    mart = ensembl
  )

  return(annotated_data)
}

```
```{r}
ensembl_genes <- annotate_ensembl_symbol2ensembl(msigdb_cp_t2g$gene_symbol)
```

TNF genes
```{r}
TNF_genes <- msigdb_all_filt %>%
  dplyr::filter(gs_name == "REACTOME_TELOMERE_MAINTENANCE") %>%
  dplyr::rename(uniprot_gn_symbol=gene_symbol) %>%
  left_join(ensembl_genes, by="uniprot_gn_symbol")
  
TNFss_all <- ss_select_all %>%
  dplyr::filter(gene %in% TNF_genes$ensembl_gene_id) %>%
  group_by(taxa) %>%
  summarize(num_genes_TNF = n()) %>%
  arrange(desc(num_genes_TNF))
TNFss_urban <- ss_select_urban %>%
  dplyr::filter(gene %in% TNF_genes$ensembl_gene_id) %>%
  group_by(taxa) %>%
  summarize(num_genes_TNF = n()) %>%
  arrange(desc(num_genes_TNF))
TNFss_rural <- ss_select_rural %>%
  dplyr::filter(gene %in% TNF_genes$ensembl_gene_id) %>%
  group_by(taxa) %>%
  summarize(num_genes_TNF = n()) %>%
  arrange(desc(num_genes_TNF))
```

Microbe - TNF assocations by urbanism
```{r}
# Define the function
join_num_genes_TNF <- function(glm_results_urbanism, TNFss_summary) {
  
  # Iterate over each dataframe in the nested list
  glm_results_urbanism <- lapply(glm_results_urbanism, function(df) {
    
    # Perform a left_join to add num_genes, filling missing values with 0
    df <- df %>%
      left_join(TNFss_summary, by = "taxa") %>%
      mutate(num_genes_TNF = ifelse(is.na(num_genes_TNF), 0, num_genes),
             has_genes_TNF = ifelse(num_genes_TNF > 0, 1, 0)) # Binarize column
    
    return(df)
  })
  
  return(glm_results_urbanism)
}
```

```{r}
TNF_results_urbanism_lasso_all <- join_num_genes_TNF(glm_results_urbanism_lasso_all, TNFss_all)
TNF_results_urbanism_lasso_urban <- join_num_genes_TNF(glm_results_urbanism_lasso_urban, TNFss_urban)
TNF_results_urbanism_lasso_rural <- join_num_genes_TNF(glm_results_urbanism_lasso_rural, TNFss_rural)
```
```{r}
# Define the function
plot_TNF_bargraph <- function(df) {
  
  # Filter the dataframe by pval.holm < 0.1
  df_filtered <- df %>%
    mutate(enriched_in_sig = case_when(pval.holm > 0.1 ~ "NotSig_DA", T~enriched_in ))
  #df_filtered <- df[df$pval.holm < 1, ]
  df_filtered <- df_filtered[df_filtered$num_genes_TNF > 0, ]
  df_filtered$taxa <- factor(df_filtered$taxa, levels = df_filtered$taxa[order(df_filtered$num_genes_TNF, decreasing = F)])
  
  # Create the bar plot faceted by 'enriched_in'
  p <- ggplot(df_filtered, aes(x = taxa, y = num_genes_TNF, fill = enriched_in)) +
    
    # Bar plot with color based on 'enriched_in' value
    geom_bar(stat = "identity") +
    
    # Customize fill color: purple for 'Industrialized', green for others
    scale_fill_manual(values = c("Industrialized" = "purple", "Non-Industrialized" = "green")) +
    facet_grid(~enriched_in_sig, scales="free_x", space="free") +
     
    # Labels and theme
    labs(x = "Taxa", y = "Number of TNF-related Genes") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) 
  
  return(p)
}

# Usage:
# plot_TNF_bargraph(your_dataframe)

```
```{r}
plot_TNF_bargraph(TNF_results_urbanism_lasso_all[["s"]])
plot_TNF_bargraph(TNF_results_urbanism_lasso_urban[["s"]])
plot_TNF_bargraph(TNF_results_urbanism_lasso_rural[["s"]])
```













Check for overlap between lasso models

```{r}
common_values <- Reduce(intersect, list(ss_select_rural$gene_taxa, ss_select_urban$gene_taxa))
common_values

gene_counts_rural <- ss_select_rural %>%
  group_by(gene) %>%
  summarise(count = n()) #%>%
  #filter(count >= 2)

gene_counts_rural <- ss_select_rural %>%
  inner_join(gene_counts_rural, by = "gene")

taxa_counts_rural <- gene_counts_rural %>%
  group_by(taxa) %>%
  summarise(count = n()) %>%
  dplyr::filter(count > 11)



gene_counts_urban <- ss_select_urban %>%
  group_by(gene) %>%
  summarise(count = n()) #%>%
  #filter(count >= 2)

gene_counts_urban <- ss_select_urban %>%
  inner_join(gene_counts_urban, by = "gene")

taxa_counts_urban <- gene_counts_urban %>%
  group_by(taxa) %>%
  summarise(count = n()) %>%
  dplyr::filter(count > 11)



gene_counts_urban2 <- gene_counts_urban %>%
  dplyr::filter(taxa %in% cbind(taxa_counts_urban$taxa, taxa_counts_rural$taxa))
gene_counts_rural2 <- gene_counts_rural %>%
  dplyr::filter(taxa %in% cbind(taxa_counts_urban$taxa, taxa_counts_rural$taxa))


# Display the result
print(gene_counts_rural)
print(gene_counts_urban)

print(taxa_counts_rural)
print(taxa_counts_urban)


```

```{r}
lasso_all_select <- lasso_all %>%
  dplyr::filter(gene %in% c(gene_counts_rural$gene, gene_counts_urban$gene)) %>%
  dplyr::filter(taxa %in% c(ss_select_rural$taxa, ss_select_urban$taxa))

lasso_urban_select <- lasso_urban %>%
  dplyr::filter(gene %in% c(gene_counts_rural$gene, gene_counts_urban$gene)) %>%
  dplyr::filter(taxa %in% c(ss_select_rural$taxa, ss_select_urban$taxa))

lasso_rural_select <- lasso_rural %>%
  dplyr::filter(gene %in% c(gene_counts_rural$gene, gene_counts_urban$gene)) %>%
  dplyr::filter(taxa %in% c(ss_select_rural$taxa, ss_select_urban$taxa))
```

```{r}
# THIS IS A SHORTCUT BUT BRING DOWN UNION TO SPECIES ONLY BY SELECTING TAXA WITH UNDERSCORE
# NOT SUPER CORRECT NEED TO FIX LATER
#union_sigtaxa_s <- grep("_", union_sigtaxa, value = TRUE)

union_siggenes <- unique(c(gene_counts_urban2$gene, gene_counts_rural2$gene))
union_sigtaxa <- unique(c(gene_counts_urban2$taxa, gene_counts_rural2$taxa))

union_sigtaxa_s <- grep("_", union_sigtaxa, value = TRUE)
gene_counts_urban3 <- dplyr::filter(gene_counts_urban2, taxa %in% union_sigtaxa_s)
gene_counts_rural3 <- dplyr::filter(gene_counts_urban2, taxa %in% union_sigtaxa_s)
union_siggenes_s <- unique(c(gene_counts_urban3$gene, gene_counts_rural3$gene))

lasso_all_select2 <- lasso_all %>%
  dplyr::filter(gene %in% union_siggenes_s) %>%
  dplyr::filter(taxa %in% union_sigtaxa_s)

lasso_urban_select2 <- lasso_urban %>%
  dplyr::filter(gene %in% union_siggenes_s) %>%
  dplyr::filter(taxa %in% union_sigtaxa_s)

lasso_rural_select2 <- lasso_rural %>%
  dplyr::filter(gene %in% union_siggenes_s) %>%
  dplyr::filter(taxa %in% union_sigtaxa_s)
```

Re-create Sambhawa's figure. Correlation of union of expression of ss-selected genes and union of abundances of ss-selected microbes.

```{r}
# Define genes and microbes of interest
ss_gene_union <- unique(union(ss_select_urban$gene, ss_select_rural$gene))
ss_gene_union <- setdiff(ss_gene_union, "ENSG00000165879")
ss_taxa_union <- unique(union(ss_select_urban$taxa, ss_select_rural$taxa))
# REMOVE THIS LATER
ss_taxa_union <- setdiff(ss_taxa_union, c("Coprobacillus", "Butyricicoccus", "Eggerthellaceae", "Porphyromonadaceae","Aeromonadales"))
length(ss_gene_union)
length(ss_taxa_union)

# Extract gene counts and microbe counts in each treatment

genes_to_select <- setdiff(unique(ss_select_rural$gene), "ENSG00000165879")

ss_taxa_abundance_urban <- dplyr::select(as.data.frame(microbes_urban), ss_taxa_union) #%>%
  #dplyr::one_of(genes_to_select)
ss_taxa_abundance_rural <- dplyr::select(as.data.frame(microbes_rural), ss_taxa_union) #%>%
  #dplyr::one_of(genes_to_select)
ss_taxa_abundance_all <- dplyr::select(as.data.frame(microbes), unique(ss_select_all$taxa)) #%>%
  #dplyr::one_of(genes_to_select)

ss_gene_abundance_all <- dplyr::select(as.data.frame(genes_bc_vst_varfilt), unique(ss_select_all$gene))
ss_gene_abundance_urban <- dplyr::select(as.data.frame(genes_urban), ss_gene_union)
ss_gene_abundance_rural <- dplyr::select(as.data.frame(genes_rural), ss_gene_union)

#ss_taxa_abundance_urban <- dplyr::select(as.data.frame(microbes_urban), unique(ss_select_urban$taxa))
#ss_taxa_abundance_rural <- dplyr::select(as.data.frame(microbes_rural), unique(ss_select_rural$taxa))

#ss_gene_abundance_urban <- dplyr::select(as.data.frame(genes_urban), unique(ss_select_urban$gene))
#ss_gene_abundance_rural <- dplyr::select(as.data.frame(genes_rural), dplyr::one_of(genes_to_select))




# Correlation of gene matrix and microbe matrix
correlate_matrices <- function(A, B, method = "spearman") {
  # Check if matrices have the same number of rows
  if (nrow(A) != nrow(B)) {
    stop("Matrices A and B must have the same number of rows")
  }
  
  # Initialize an empty matrix to store the correlation results
  cor_matrix <- matrix(NA, ncol = ncol(A), nrow = ncol(B))
  rownames(cor_matrix) <- colnames(B)
  colnames(cor_matrix) <- colnames(A)
  
  # Calculate the correlation between each pair of columns
  for (i in seq_len(ncol(A))) {
    for (j in seq_len(ncol(B))) {
      cor_matrix[j, i] <- cor(A[, i], B[, j], method = method)
    }
  }
  
  return(cor_matrix)
}

```
Just plot a few
```{r}
genetaxa_specific_func <- function(gene_df, taxa_df, taxa, gene, gene_name) {
  gene_taxa <- c(gene, taxa)
  
  gene_df <- gene_df %>% rownames_to_column("SampleID")
  
  taxa_df <- taxa_df %>%
    as.data.frame() %>%
    rownames_to_column("SampleID")
  
  joined_df <- merge(gene_df, taxa_df, by = "SampleID") %>%
    dplyr::select(SampleID, all_of(gene_taxa)) %>%
    dplyr::filter(SampleID %in% meta$SampleID)
  
  ggplot(joined_df, aes_string(x = taxa, y = gene)) +
    geom_point(color = "maroon") +
    geom_smooth(method = "lm", color = "black") +
    theme_linedraw() +
    labs(x = taxa, y = gene_name)
}


genetaxa_specific_func(ss_gene_abundance_all, ss_taxa_abundance_all, "Bifidobacterium_adolescentis", "ENSG00000163931", "TKT")
ggsave("results/figs/lifestyle/bifido_tkt.png", width=3, height=3)
genetaxa_specific_func(ss_gene_abundance_all, ss_taxa_abundance_all, "Bifidobacterium_adolescentis", "ENSG00000212724", "KRTAP2-3")
ggsave("results/figs/lifestyle/bifido_krtap2-3.png", width=3, height=3)

genetaxa_specific_func(ss_gene_abundance_all, ss_taxa_abundance_all, "Bacteroides_dorei", "ENSG00000142871", "CCN1")
ggsave("results/figs/lifestyle/bac_ccn1.png", width=3, height=3)
genetaxa_specific_func(ss_gene_abundance_all, ss_taxa_abundance_all, "Bacteroides_dorei", "ENSG00000169991", "IFFO2")
ggsave("results/figs/lifestyle/bac_iffo2.png", width=3, height=3)

genetaxa_specific_func(ss_gene_abundance_all, ss_taxa_abundance_all, "Phascolarctobacterium_A_sp022718015", "ENSG00000112033", "PPARD")
ggsave("results/figs/lifestyle/phas_ppard.png", width=3, height=3)
genetaxa_specific_func(ss_gene_abundance_all, ss_taxa_abundance_all, "Phascolarctobacterium_A_sp022718015", "ENSG00000184254", "ALDH1A3")
ggsave("results/figs/lifestyle/phas_ald.png", width=3, height=3)
genetaxa_specific_func(ss_gene_abundance_all, ss_taxa_abundance_all, "Phascolarctobacterium_A_sp022718015", "ENSG00000073737", "DHRS9")
ggsave("results/figs/lifestyle/phas_dhr.png", width=3, height=3)
genetaxa_specific_func(ss_gene_abundance_all, ss_taxa_abundance_all, "Phascolarctobacterium_A_sp022718015", "ENSG00000075624", "ACTB")
ggsave("results/figs/lifestyle/phas_actb.png", width=3, height=3)
genetaxa_specific_func(ss_gene_abundance_all, ss_taxa_abundance_all, "Phascolarctobacterium_A_sp022718015", "ENSG00000156299", "TIAM1")
ggsave("results/figs/lifestyle/phas_tiam1.png", width=3, height=3)


```

```{r}
ss_urban_genetaxa_cor <- correlate_matrices(ss_taxa_abundance_urban, ss_gene_abundance_urban)
ss_rural_genetaxa_cor <- correlate_matrices(ss_taxa_abundance_rural, ss_gene_abundance_rural)
```

```{r}
library(pheatmap)
library(RColorBrewer)


breaksList = seq(-1, 1, by = 0.1)

heatmap_urban <- pheatmap(ss_urban_genetaxa_cor,
                          show_colnames = FALSE,
                      cluster_rows = T,  
                      cluster_cols = T, 
                      color = colorRampPalette(rev(brewer.pal(n = 11, name = "RdBu")))(length(breaksList)),
                      breaks = breaksList,
                      fontsize_number = 0,           # Font size for numbers (annotations)
                      main = "Heatmap of spearman")
  
# Extract row and column order from urban_gene_heatmap
urban_row_order <- heatmap_urban$tree_row$labels
urban_col_order <- heatmap_urban$tree_col$labels

heatmap_rural <- pheatmap(ss_rural_genetaxa_cor,
                          show_colnames = FALSE,
                      cluster_rows = T,  # Use the same order as urban
                      cluster_cols = T,  # Use the same order as urban
                      color = colorRampPalette(rev(brewer.pal(n = 11, name = "RdBu")))(length(breaksList)),
                      breaks = breaksList,
                      fontsize_number = 0,           # Font size for numbers (annotations)
                      main = "Heatmap of spearman")

# Generate the rural heatmap with the same order as urban_gene_heatmap
heatmap_rural <- pheatmap(ss_rural_genetaxa_cor[urban_row_order, urban_col_order, drop = FALSE],
                          show_colnames = FALSE,
                      cluster_rows = FALSE,  # Use the same order as urban
                      cluster_cols = FALSE,  # Use the same order as urban
                      color = colorRampPalette(rev(brewer.pal(n = 11, name = "RdBu")))(length(breaksList)),
                      breaks = breaksList,
                      fontsize_number = 0,           # Font size for numbers (annotations)
                      main = "Heatmap of spearman")



#save_pheatmap_png(heatmap_urban, "results/figs/RNAseq-metaG-microbe-Lasso/urban_gene_heatmap.png")
#save_pheatmap_png(heatmap_rural, "results/figs/RNAseq-metaG-microbe-Lasso/rural_gene_heatmap.png")
```
Median value??
```{r}
mean(abs(ss_select_urban$beta_est))
range(abs(ss_select_urban$beta_est))

mean(abs(ss_select_rural$beta_est))
range(abs(ss_select_rural$beta_est))
```





Print the genes that match to interesting microbes

```{r}
test <- ss_select_rural %>%
  dplyr::filter(taxa == "Unknown_genus_15") %>%
  pull(gene)
library(clipr)
write_clip(test)
```

Check for overlap with sparse cca data

```{r}
CCA_microbe_elements <- readRDS("results/rds/CCA_microbe_elements_all.rds")
genes = CCA_microbe_elements[["genes"]]
genes_urban = CCA_microbe_elements[["genes_urban"]]
genes_rural = CCA_microbe_elements[["genes_rural"]]
sig_df = CCA_microbe_elements[["sig_all_df"]]
sig_urban_df = CCA_microbe_elements[["sig_urban_df"]]
sig_rural_df = CCA_microbe_elements[["sig_rural_df"]]
sig_microbes = CCA_microbe_elements[["sig_all_microbes"]]
sig_urban_microbes = CCA_microbe_elements[["sig_urban_microbes"]]
sig_rural_microbes = CCA_microbe_elements[["sig_rural_microbes"]]
sig_genes = CCA_microbe_elements[["sig_all_genes"]]
sig_urban_genes = CCA_microbe_elements[["sig_urban_genes"]]
sig_rural_genes = CCA_microbe_elements[["sig_rural_genes"]]
```

Make new df that is same structure to ss lasso

```{r}
process_nested_element <- function(cca_element) {
  # Extract and clean the microbes list
  microbes <- unlist(cca_element$taxa)
  microbes <- microbes[!is.na(microbes)]
  
  # Extract the unique genes
  genes <- unique(cca_element$gene)
  
  # Create a data frame with the Cartesian product of genes and microbes
  gene_microbe_pairs <- expand.grid(gene = genes, taxa = microbes)
  
  # Create the gene_taxa column
  gene_microbe_pairs <- gene_microbe_pairs %>%
    mutate(gene_taxa = paste(gene, taxa, sep=":"))
  
  return(gene_microbe_pairs)
}

# Main function to process nested list
cca_format <- function(nested_list) {
  lapply(nested_list, process_nested_element)
}

sig_df_format <- cca_format(sig_df)
sig_urban_df_format <- cca_format(sig_urban_df)
sig_rural_df_format <- cca_format(sig_rural_df)
```

```{r}
# Function to filter each data frame in the nested list by another data frame using gene_taxa
filter_by_gene_taxa <- function(nested_list, filter_df) {
  lapply(nested_list, function(df) {
    df %>% dplyr::filter(gene_taxa %in% filter_df$gene_taxa)
  })
}
```

```{r}
cca_lasso_overlap_all <- filter_by_gene_taxa(sig_df_format, ss_select_all)
cca_lasso_overlap_urban <- filter_by_gene_taxa(sig_urban_df_format, ss_select_urban)
cca_lasso_overlap_rural <- filter_by_gene_taxa(sig_rural_df_format, ss_select_rural)
```

```{r}
# Create a nested list of data frames by unique values in the 'taxa' column
ss_select_all_nested <- split(ss_select_all, ss_select_all$taxa)
ss_select_urban_nested <- split(ss_select_urban, ss_select_urban$taxa)
ss_select_rural_nested <- split(ss_select_rural, ss_select_rural$taxa)

# Pare down to microbes with >10 genes
ss_select_all_nested2 <- Filter(function(df) nrow(df) >= 2, ss_select_all_nested)
ss_select_all_nested3 <- Filter(function(df) nrow(df) >= 3, ss_select_all_nested)
ss_select_all_nested5 <- Filter(function(df) nrow(df) >= 5, ss_select_all_nested)
ss_select_all_nested10 <- Filter(function(df) nrow(df) >= 10, ss_select_all_nested)
ss_select_urban_nested10 <- Filter(function(df) nrow(df) >= 10, ss_select_urban_nested)
ss_select_rural_nested10 <- Filter(function(df) nrow(df) >= 10, ss_select_rural_nested)
```

Functional analysis

```{r}
annotate_ensembl <- function(ensembl_ids) {
  ensembl = useEnsembl(biomart = "ensembl", dataset = "hsapiens_gene_ensembl")#, host = "jul2023.archive.ensembl.org") #, host = "jul2023.archive.ensembl.org"

  # Define annotations
  att_interest <- c("ensembl_gene_id", "uniprot_gn_symbol") #, "uniprot_gn_id", "entrezgene_id"

  # Annotate
  annotated_data <- biomaRt::getBM(
    attributes = att_interest,
    filters = "ensembl_gene_id",
    values = ensembl_ids,
    mart = ensembl
  )

  return(annotated_data)
}
```

```{r}
ss_select_all_nested2_anno <- lapply(ss_select_all_nested2, function(ensembl_ids) {
  if (length(ensembl_ids) > 0) {
    return(annotate_ensembl(ensembl_ids))
  } else {
    return(data.frame(ensembl_gene_id = character(), uniprot_gn_symbol = character(), uniprot_gn_id = character(), entrezgene_id = character()))
  }
})
```

```{r}
ss_select_all_nested3_anno <- lapply(ss_select_all_nested3, function(ensembl_ids) {
  if (length(ensembl_ids) > 0) {
    return(annotate_ensembl(ensembl_ids))
  } else {
    return(data.frame(ensembl_gene_id = character(), uniprot_gn_symbol = character(), uniprot_gn_id = character(), entrezgene_id = character()))
  }
})
```

```{r}
ss_select_all_nested5_anno <- lapply(ss_select_all_nested5, function(ensembl_ids) {
  if (length(ensembl_ids) > 0) {
    return(annotate_ensembl(ensembl_ids))
  } else {
    return(data.frame(ensembl_gene_id = character(), uniprot_gn_symbol = character(), uniprot_gn_id = character(), entrezgene_id = character()))
  }
})
```

```{r}
ss_select_all_nested10_anno <- lapply(ss_select_all_nested10, function(ensembl_ids) {
  if (length(ensembl_ids) > 0) {
    return(annotate_ensembl(ensembl_ids))
  } else {
    return(data.frame(ensembl_gene_id = character(), uniprot_gn_symbol = character(), uniprot_gn_id = character(), entrezgene_id = character()))
  }
})
```

```{r}
ss_select_urban_nested10_anno <- lapply(ss_select_urban_nested10, function(ensembl_ids) {
  if (length(ensembl_ids) > 0) {
    return(annotate_ensembl(ensembl_ids))
  } else {
    return(data.frame(ensembl_gene_id = character(), uniprot_gn_symbol = character(), uniprot_gn_id = character(), entrezgene_id = character()))
  }
})
```

```{r}
ss_select_rural_nested10_anno <- lapply(ss_select_rural_nested10, function(ensembl_ids) {
  if (length(ensembl_ids) > 0) {
    return(annotate_ensembl(ensembl_ids))
  } else {
    return(data.frame(ensembl_gene_id = character(), uniprot_gn_symbol = character(), uniprot_gn_id = character(), entrezgene_id = character()))
  }
})
```

Define universe

```{r}
uni <- rownames(genes_bc)
uni <- annotate_ensembl(uni)
uni_uniprot <- unlist(list(uni$uniprot_gn_id))
uni_entrez <- unlist(list(uni$entrez_gene_id))

uni_urban <- rownames(genes_urban)
uni_urban <- annotate_ensembl(uni_urban)
uni_urban_uniprot <- unlist(list(uni_urban$uniprot_gn_id))
uni_urban_entrez <- unlist(list(uni_urban$entrez_gene_id))

uni_rural <- rownames(genes_rural)
uni_rural <- annotate_ensembl(uni_rural)
uni_rual_uniprot <- unlist(list(uni_rural$uniprot_gn_id))
uni_rural_entrez <- unlist(list(uni_rural$entrez_gene_id))
```

```{r}
library(msigdbr)

#msigdbr_collections()

# download databases of interest
msigdb_h = msigdbr(species = "human", category = "H")
msigdb_cpPID = msigdbr(species = "human", category = "C2", subcategory = "CP:PID")
msigdb_cpKEGG = msigdbr(species = "human", category = "C2", subcategory = "CP:KEGG")
msigdb_cpREACTOME = msigdbr(species = "human", category = "C2", subcategory = "CP:REACTOME")
msigdb_cpBIOCARTA = msigdbr(species = "human", category = "C2", subcategory = "CP:BIOCARTA")
msigdb_cgp = msigdbr(species = "human", category = "C2", subcategory = "CGP") %>%
  mutate(gs_name = paste("CGP", gs_name, sep = "_"))
msigdb_cgn = msigdbr(species = "human", category = "C4", subcategory = "CGN") %>%
  mutate(gs_name = paste("CGN", gs_name, sep = "_"))
msigdb_cm = msigdbr(species = "human", category = "C4", subcategory = "CM") %>%
  mutate(gs_name = paste("CM", gs_name, sep = "_"))
msigdb_IMMUNESIGDB = msigdbr(species = "human", category = "C7", subcategory = "IMMUNESIGDB") %>%
  mutate(gs_name = paste("IMMUNESIGDB", gs_name, sep = "_"))

# Experimenting with pasting these all together to reduce code burden
msigdb_cp <- rbind(msigdb_cpKEGG, msigdb_cpREACTOME) %>%
  rbind(msigdb_cpPID)

msigdb_all <- rbind(msigdb_cpKEGG, msigdb_cpREACTOME) %>% #, msigdb_cpREACTOME
  rbind(msigdb_cpPID) %>%
  rbind(msigdb_cpBIOCARTA) %>%
  rbind(msigdb_h) #%>%
  #rbind(msigdb_cgp) %>%
  #rbind(msigdb_cgn) %>%
  #rbind(msigdb_cm)  %>%
  #rbind(msigdb_IMMUNESIGDB)
  
# Summarize metrics from all pathways from all databases
msigdb_cp_summary <- msigdb_cp %>%
  group_by(gs_name) %>%
  summarize(GeneCount = n_distinct(gene_symbol)) %>%
  # sambhawas filtering cutoffs
  dplyr::filter(GeneCount > 25, GeneCount < 300)

msigdb_all_summary <- msigdb_all %>%
  group_by(gs_name) %>%
  summarize(GeneCount = n_distinct(gene_symbol)) %>%
  # sambhawas filtering cutoffs
  dplyr::filter(GeneCount > 25, GeneCount < 300)

# Narrow down pathways that meet our thresholds  
msigdb_cp_filt <- msigdb_cp %>%
  dplyr::filter(gs_name %in% msigdb_cp_summary$gs_name)
msigdb_cpPID_filt <- msigdb_cpPID %>%
  dplyr::filter(gs_name %in% msigdb_cp_summary$gs_name)
msigdb_cpKEGG_filt <- msigdb_cpKEGG %>%
  dplyr::filter(gs_name %in% msigdb_cp_summary$gs_name)
msigdb_cpREACTOME_filt <- msigdb_cpREACTOME %>%
  dplyr::filter(gs_name %in% msigdb_cp_summary$gs_name)
msigdb_cpBIOCARTA_filt <- msigdb_cpBIOCARTA %>%
  dplyr::filter(gs_name %in% msigdb_cp_summary$gs_name)

msigdb_all_filt <- msigdb_all %>%
  dplyr::filter(gs_name %in% msigdb_all_summary$gs_name)
```

clusterProfiler for enrichment analysis.

```{r}
library(clusterProfiler)

# df of distinct gene symbols
# TERM2GENE is a data frame with first column of term ID and second column of corresponding mapped gene
msigdb_cp_t2g = msigdb_all_filt %>% dplyr::distinct(gs_name, gene_symbol) %>% as.data.frame()
```

```{r}
perform_enrichment <- function(input, msigdb_cp_t2g, uni, model, dir) {
  enrich_res_list <- list()  # List to store all enrichment results
  enrich_sig_list <- list()  # List to store significant enrichments
  
  for (i in seq_along(input)) {
    df <- input[[i]]  # Extract the dataframe
    # Extract symbols from the current dataframe
    symbols <- df$uniprot_gn_symbol
    
    # Perform enrichment analysis for the current list of symbols
    enrich <- enricher(gene = unique(symbols),
                       TERM2GENE = msigdb_cp_t2g,
                       universe = uni$hgnc_symbol)
    
    # Extract results
    enrich_res <- enrich@result %>% mutate(model = model, dir = dir, component = names(input)[i])
    enrich_res <- enrich_res %>% mutate(model_dir_component = paste(model, dir, component, sep="."))
    
    # Filter significant enrichments
    enrich_sig <- enrich_res %>% filter(Count > 1, p.adjust < 0.1)
    
    # Store results for the current dataframe
    enrich_res_list[[i]] <- enrich_res
    enrich_sig_list[[i]] <- enrich_sig
  }
  
  return(list(enrich_res_list = enrich_res_list, enrich_sig_list = enrich_sig_list))
}

```

Overrep of all genes that are significant in lasso
```{r}
ss_select_all_geneenrich <- annotate_ensembl(genesummary_ss_select_all$gene)

m_t2g <- msigdbr(species = "Homo sapiens", category = "C2") %>% 
  dplyr::select(gs_name, gene_symbol)


ss_select_all_geneenrich_enrich <- enricher(gene =  unique(ss_select_all_geneenrich$uniprot_gn_symbol),
                       TERM2GENE = m_t2g,
                       universe = uni$uniprot_gn_symbol)
    
    # Extract results
ss_select_all_geneenrich_res <- ss_select_all_geneenrich_enrich@result 
    
    # Filter significant enrichments
ss_select_all_geneenrich_sig <- ss_select_all_geneenrich_res %>% dplyr::filter(Count > 0, p.adjust < 0.1)
    
```
Enrichment of all genes that are significant in lasso
```{r}
ss_select_all_geneenrich <- annotate_ensembl(genesummary_ss_select_all$gene)

m_t2g <- msigdbr(species = "Homo sapiens", category = "C2") %>% 
  dplyr::select(gs_name, gene_symbol)


ss_select_all_geneenrich_enrich <- enricher(gene =  unique(ss_select_all_geneenrich$uniprot_gn_symbol),
                       TERM2GENE = m_t2g,
                       universe = uni$uniprot_gn_symbol)
    
    # Extract results
ss_select_all_geneenrich_res <- ss_select_all_geneenrich_enrich@result 
    
    # Filter significant enrichments
ss_select_all_geneenrich_sig <- ss_select_all_geneenrich_res %>% dplyr::filter(Count > 0, p.adjust < 0.1)
    
```

Overrep of all genes that are diff abun in diet or blood
```{r}
lifestyle_enrich <- function(feature_list) {
  # Filter ss_select_all based on feature list
  ss_select_all_feature <- ss_select_all %>%
    dplyr::filter(taxa %in% feature_list)
  
  # Annotate ensembl genes in the filtered feature list
  symbols <- annotate_ensembl(unique(ss_select_all_feature$gene))
  
  # Extract unique symbols
  unique_symbols <- unique(symbols$uniprot_gn_symbol)

  # Perform enrichment analysis using the unique symbols
  enrich <- enricher(
    gene = unique_symbols,
    TERM2GENE = msigdb_cp_t2g,
    universe = uni$uniprot_gn_symbol
  )
  
  # Extract results
  enrich_res <- enrich@result
  
  # Filter significant enrichments
  enrich_sig <- enrich_res %>% dplyr::filter(Count > 1, p.adjust < 0.1)
  
  return(enrich_sig)
}

shared_genes <- function(feature_list){
  # Filter ss_select_all based on feature list
  ss_select_all_feature <- ss_select_all %>%
    dplyr::filter(taxa %in% feature_list)
  
  # Annotate ensembl genes in the filtered feature list
  symbols <- annotate_ensembl(unique(ss_select_all_feature$gene))
  
  # Extract unique symbols
  unique_symbols <- unique(symbols$uniprot_gn_symbol)
  
  # Check for shared genes across multiple taxa
  shared_genes <- ss_select_all_feature %>%
    dplyr::group_by(gene) %>%
    dplyr::summarize(taxa_count = n_distinct(taxa)) %>%
    dplyr::filter(taxa_count > 1)
  
  # If there are shared genes, print them as a dataframe
  if (nrow(shared_genes) > 0) {
    print("Shared genes across multiple taxa:")
    print(shared_genes)
  }
}
```
Diet PC1
```{r}
diet_features_neg <- c(
"Treponema_succinifaciens",
"Catenibacterium_sp_2",
"Prevotella_sp_3",
"Holdemanella",
"Treponema",
"Holdemanella_sp_2",
"Holdemanella_biformis",
"Coprococcus_sp_4",
"Catenibacterium_sp_1",
"Catenibacterium",
"Phascolarctobacterium_succinatutens",
"Dialister_sp_1",
"Prevotella_sp_4",
"Coprococcus_eutactus",
"Coprococcus_sp_3",
"Roseburia_sp_1",
"Ruminococcus_sp_5",
"Coprococcus",
"Dorea_sp_1",
"Ruminococcus_sp_4"
  )

diet_features_pos <- c(
"Bacteroides_xylanisolvens",
"Odoribacter",
"Bacteroides_thetaiotaomicron",
"Odoribacter_splanchnicus",
"Bacteroides_uniformis",
"Bacteroides_ovatus",
"Alistipes",
"Bifidobacterium",
"Bifidobacterium_longum",
"Bacteroides_dorei",
"Bacteroides_finegoldii",
"Megasphaera",
"Bacteroides_massiliensis",
"Alistipes_shahii",
"Alistipes_communis",
"Bacteroides",
"Parabacteroides",
"Parabacteroides_distasonis",
"Acidaminococcus",
"Bifidobacterium_adolescentis",
"Parabacteroides_merdae",
"Bacteroides_vulgatus",
"Acidaminococcus_intestini",
"Bacteroides_stercoris",
"Bacteroides_sp_2",
"Bacteroides_caccae",
"Alistipes_putredinis"
)

diet_neg_enrich_sig <- lifestyle_enrich(diet_features_neg)
diet_pos_enrich_sig <- lifestyle_enrich(diet_features_pos)
diet_enrich_sig <- lifestyle_enrich(unlist(c(diet_features_neg,diet_features_pos)))
diet_shared <- shared_genes(unlist(c(diet_features_neg,diet_features_pos)))
```
IgA
```{r}
iga_features_neg <- c(
  "Dialister_sp_1",
"Prevotella_sp_3",
"Catenibacterium_sp_2",
"Catenibacterium",
"Holdemanella_sp_2"
  )

iga_features_pos <- c(
"Odoribacter_splanchnicus",
"Bacteroides_ovatus",
"Odoribacter",
"Parabacteroides",
"Bacteroides_dorei",
"Bacteroides",
"Bacteroides_finegoldii",
"Bacteroides_caccae",
"Bacteroides_vulgatus",
"Bacteroides_sp_2",
"Bacteroides_stercoris",
"Alistipes_putredinis"
)

iga_neg_enrich_sig <- lifestyle_enrich(iga_features_neg)
iga_pos_enrich_sig <- lifestyle_enrich(iga_features_pos)
iga_enrich_sig <- lifestyle_enrich(unlist(c(iga_features_neg,iga_features_pos)))
iga_shared <- shared_genes(unlist(c(iga_features_neg,iga_features_pos)))
```
Antiparasite
```{r}
antip_features_neg <- c(
  "Prevotella",
"Prevotella_sp_4",
"Prevotella_sp_1",
"Prevotella_copri",
"Eubacterium_rectale",
"Prevotella_sp_3",
"Prevotella_sp_5",
"Roseburia",
"Eubacterium_sp_4",
"Prevotella_sp_7",
"Prevotella_sp_2",
"Dorea"
  )

antip_features_pos <- c(
  "Akkermansia_muciniphila",
"Ruthenibacterium_lactatiformans",
"Ruthenibacterium",
"Odoribacter",
"Odoribacter_splanchnicus",
"Alistipes_shahii",
"Oscillibacter",
"Oscillibacter_sp_1"
)

antip_neg_enrich_sig <- lifestyle_enrich(antip_features_neg)
#antip_pos_enrich_sig <- lifestyle_enrich(antip_features_pos)
antip_enrich_sig <- lifestyle_enrich(unlist(c(antip_features_neg,antip_features_pos)))
antip_shared <- shared_genes(unlist(c(antip_features_neg,antip_features_pos)))
```
Blood PC1
```{r}
#blood_features_neg <- c(
  #)

blood_features_pos <- c(
  "Bacteroides",
"Parabacteroides",
"Bacteroides_stercoris",
"Bacteroides_vulgatus"
)

#blood_neg_enrich_sig <- lifestyle_enrich(blood_features_neg)
blood_pos_enrich_sig <- lifestyle_enrich(blood_features_pos)
#blood_enrich_sig <- lifestyle_enrich(unlist(c(blood_features_neg,blood_features_pos)))
blood_shared <- shared_genes(blood_features_pos)
```
Oral topical medication
```{r}
otm_features_neg <- c(
  "Streptomyces",
"Barnesiella"
  )

#otm_features_pos <- c(
#)

otm_neg_enrich_sig <- lifestyle_enrich(otm_features_neg)
#otm_pos_enrich_sig <- lifestyle_enrich(otm_features_pos)
#otm_enrich_sig <- lifestyle_enrich(unlist(c(otm_features_neg,otm_features_pos)))
otm_shared <- shared_genes(otm_features_neg)
```

```{r}
all_lifestyle_features <- unlist(c(diet_features_neg, diet_features_pos, iga_features_neg, iga_features_pos, antip_features_neg, antip_features_pos, blood_features_pos, otm_features_neg))

ss_select_all_nested3_anno_lifestyle <-  ss_select_all_nested3_anno[names(ss_select_all_nested3_anno) %in% all_lifestyle_features]
```

```{r}
sig_genes_anno_enrich <- perform_enrichment(ss_select_all_nested10_anno, msigdb_cp_t2g, uni, "all", "NA") 

#ss_select_all_nested3_anno_lifestyle
sig_genes_anno_enrich_2 <- perform_enrichment(ss_select_all_nested2_anno, msigdb_cp_t2g, uni, "all", "NA")

sig_urban_genes_anno_enrich <- perform_enrichment(ss_select_urban_nested10_anno, msigdb_cp_t2g, uni_urban, "urban", "NA")

sig_rural_genes_anno_enrich <- perform_enrichment(ss_select_rural_nested10_anno, msigdb_cp_t2g, uni_rural, "rural", "NA")

```
```{r}
library(clipr)
write_clip(sig_genes_anno_enrich[["enrich_sig_list"]][[10]])
```


Flatten

```{r}
all_enrich_res <- do.call(rbind, sig_genes_anno_enrich$enrich_res_list)

u_enrich_res <- do.call(rbind, sig_urban_genes_anno_enrich$enrich_res_list)

r_enrich_res <- do.call(rbind, sig_rural_genes_anno_enrich$enrich_res_list)



all_enrich_sig <- do.call(rbind, sig_genes_anno_enrich$enrich_sig_list)

u_enrich_sig <- do.call(rbind, sig_urban_genes_anno_enrich$enrich_sig_list)

r_enrich_sig <- do.call(rbind, sig_rural_genes_anno_enrich$enrich_sig_list)
```

```{r}
interesting_interactions <- data.frame(
  uniprot_gn_symbol = c(
    "TRIM56",
    "SAXO4"
  ),
  taxa = c(
    "Blautia_obeum",
    "Ruminococcus_sp_4",
    
    )) %>%
  dplyr::mutate(gene_taxa = paste(uniprot_gn_symbol, taxa, sep=":"))

interesting_taxa <- microbes %>%
  as.data.frame() %>%
  dplyr::select(unique(interesting_interactions$taxa)) %>%
  rownames_to_column("SampleID") %>%
  pivot_longer(
    cols = -SampleID,   # Pivot all columns except 'ensembl_gene_id'
    names_to = "taxa",       # The column that will hold the names of the original columns (samples)
    values_to = "abundance"   # The column that will hold the values (expression levels)
  ) 

interesting_lasso <- uni %>%
  dplyr::filter(uniprot_gn_symbol %in% interesting_interactions$uniprot_gn_symbol) #%>%
  #dplyr::filter(if_else(uniprot_gn_symbol == "H3C1", ensembl_gene_id == "ENSG00000275714", TRUE)) %>%
  #dplyr::filter(if_else(uniprot_gn_symbol == "H2BC4", ensembl_gene_id == "ENSG00000277224", TRUE))
  
residual_plot_df <- genes_bc %>%
  as.data.frame() %>%
  rownames_to_column("ensembl_gene_id") %>%
  dplyr::filter(ensembl_gene_id %in% interesting_lasso$ensembl_gene_id) %>%
  pivot_longer(
    cols = -ensembl_gene_id,   # Pivot all columns except 'ensembl_gene_id'
    names_to = "SampleID",       # The column that will hold the names of the original columns (samples)
    values_to = "expression"   # The column that will hold the values (expression levels)
  ) %>%
  merge(meta[c("SampleID", "urbanism")], by="SampleID") %>%
  merge(interesting_lasso[c("uniprot_gn_symbol", "ensembl_gene_id")], by="ensembl_gene_id") %>%
  merge(interesting_interactions[c("uniprot_gn_symbol", "taxa", "gene_taxa")], by="uniprot_gn_symbol") %>%
  merge(interesting_taxa[c("taxa", "abundance", "SampleID")], by=c("taxa", "SampleID"))

residual_plot_list <- split(residual_plot_df, residual_plot_df$gene_taxa)
```

```{r}
custom_breaks <- function(x) {
  pretty(x, n = 3)
}

ggplot(residual_plot_df, aes(x=expression, y=abundance, color=urbanism)) +
  geom_point(alpha=0.6, size=1) +
  scale_color_manual(values=c("#6FBD8B", "#7B2BC1")) +
  geom_smooth(method = "lm", se = FALSE, color = "#0077b6") +
  facet_wrap(~ gene_taxa + urbanism, ncol=2, scales="free") + #, scales="free_x"
  theme_linedraw() +
  theme(
    legend.position = "none",      # Remove the legend
    strip.background = element_blank(),  # Remove facet strip background
    strip.text = element_blank(),  # Remove facet strip text
    axis.text.x = element_text(angle = 45, hjust = 1)
  ) +
  scale_x_continuous(breaks = function(x) custom_breaks(x)) +
  scale_y_continuous(breaks = function(y) custom_breaks(y)) +
  xlab(NULL) +                     # Remove x-axis title
  ylab(NULL)
#ggsave("results/figs/RNAseq-metaG-microbe-Lasso/lasso_residuals2_LABS.png", width=2, height=9)
#ggsave("results/figs/RNAseq-metaG-microbe-Lasso/lasso_residuals_LABS.png", width=5, height=20)
```

1)  Extract name of any microbe that is significant in either lasso model
2)  Exract name of gene that is significant in either lasso model
3)  For urban model, extract beta coefficients for every microbe-gene pair, creating a matrix where rows are genes and columns and microbes. Do the same for rural model
4)  Write a function that correlates every column to every column, such that you end up with a correlation matrix among all the microbes.
5)  For urban and rural model separately, plot correlation matrix such that rows are microbes and colors and correlations.
6)  Perform hierarchial clustering (k=2?) and compare how microbes behave similarly and differently in rural and urban models.

```{r}
heatmap_taxa
```

```{r}
ss_select_all_nested5 <- Filter(function(df) nrow(df) >= 5, ss_select_all_nested)
ss_select_urban_nested5 <- Filter(function(df) nrow(df) >= 5, ss_select_urban_nested)
ss_select_rural_nested5 <- Filter(function(df) nrow(df) >= 5, ss_select_rural_nested)

# subset by greatest beta coefficients
#ss_select_urban2 <- dplyr::filter(ss_select_urban, ((beta_est > 0.05) | (beta_est < -0.05)))
#ss_select_rural2 <- dplyr::filter(ss_select_rural, ((beta_est > 0.05) | (beta_est < -0.05)))

#heatmap_genes <- c(unique(ss_select_urban2$gene), unique(ss_select_rural2$gene))
#heatmap_taxa <- c(unique(ss_select_urban2$taxa), unique(ss_select_rural2$taxa))

heatmap_taxa <- c(unique(names(ss_select_urban_nested5)), unique(names(ss_select_rural_nested5)))
ss_select_rural2 <- ss_select_rural %>% dplyr::filter(taxa %in% names(ss_select_rural_nested5))
ss_select_urban2 <- ss_select_urban %>% dplyr::filter(taxa %in% names(ss_select_urban_nested5))
heatmap_genes <- c(unique(ss_select_urban2$gene), unique(ss_select_rural2$gene))

# THIS IS A SHORTCUT BUT BRING DOWN UNION TO SPECIES ONLY BY SELECTING TAXA WITH UNDERSCORE
# NOT SUPER CORRECT NEED TO FIX LATER
union_sigtaxa_s <- grep("_", union_sigtaxa, value = TRUE)

heatmap_all_betas <- lasso_all %>%
  #dplyr::filter(gene %in% heatmap_genes) %>%
  #dplyr::filter(taxa %in% heatmap_taxa) %>%
  dplyr::select(gene, taxa, beta_est) %>%
  pivot_wider(names_from = taxa, values_from = beta_est) %>%
  column_to_rownames("gene")

heatmap_urban_betas <- lasso_urban %>%
  #dplyr::filter(gene %in% union_siggenes) %>%#dplyr::filter(gene %in% heatmap_genes) %>%
  mutate(sig = case_when(taxa %in% union_sigtaxa_s ~ "sig", T ~ "ns")) %>% #dplyr::filter(taxa %in% heatmap_taxa) %>%
  dplyr::select(gene, taxa, beta_est) %>%
  pivot_wider(names_from = taxa, values_from = beta_est) %>%
  column_to_rownames("gene")

heatmap_rural_betas <- lasso_rural %>%
  #dplyr::filter(gene %in% union_siggenes) %>% #dplyr::filter(gene %in% heatmap_genes) %>%
  #dplyr::filter(taxa %in% union_sigtaxa_s) %>% #dplyr::filter(taxa %in% heatmap_taxa) %>%
  mutate(sig = case_when(taxa %in% union_sigtaxa_s ~ "sig", T ~ "ns")) %>%
  dplyr::select(gene, taxa, beta_est) %>%
  pivot_wider(names_from = taxa, values_from = beta_est) %>%
  column_to_rownames("gene")
```

Function to create pca

```{r}
library(ggplot2)
library(factoextra)

plot_pca <- function(df, threshold) {
  # Transpose the data so that microbes are rows and genes are columns
  df_t <- t(df)
  
  # Perform PCA
  pca_result <- prcomp(df_t, scale. = TRUE)
  
  # Extract PCA results
  pca_data <- data.frame(pca_result$x)
  pca_data$taxa <- rownames(pca_data)
  pca_data <- pca_data %>%
    left_join(food_clusters, by="taxa") %>%
    mutate(food_group = as.character(food_group))
  
  # Calculate distance from the center (0,0)
  pca_data <- pca_data %>%
    mutate(distance = sqrt(PC1^2 + PC2^2))
  
  # Plot PCA using ggplot2
  pca_plot <- ggplot(pca_data, aes(x = PC1, y = PC2)) +
    geom_point(aes(color = food_group), size = 3) +
    #geom_text(aes(label = ifelse(distance > threshold, taxa, "")), vjust = -1, size = 3) +
    labs(title = "PCA of Microbes Based on Gene Expression",
         x = "Principal Component 1",
         y = "Principal Component 2") +
    theme_minimal() #+
    #theme(legend.position = "none")
  
  return(pca_plot)
}

# Example usage:
# Assuming heatmap_rural_betas is your dataframe
food_pca_rural <- plot_pca(heatmap_rural_betas,10)
food_pca_urban <- plot_pca(heatmap_urban_betas,10)

food_pca_rural
food_pca_urban

```

Function to create a correlation matrix

```{r}
calculate_spearman_correlation <- function(data_matrix) {
  # Get the column names (taxa)
  taxa <- colnames(data_matrix)
  
  # Initialize empty matrices for correlations and p-values
  correlation_matrix <- matrix(NA, nrow = length(taxa), ncol = length(taxa))
  p_value_matrix <- matrix(NA, nrow = length(taxa), ncol = length(taxa))
  rownames(correlation_matrix) <- taxa
  colnames(correlation_matrix) <- taxa
  rownames(p_value_matrix) <- taxa
  colnames(p_value_matrix) <- taxa
  
  # Function to compute Spearman correlation and p-value
  spearman_test <- function(x, y) {
    test <- cor.test(x, y, method = "spearman", use = "pairwise.complete.obs")
    list(correlation = test$estimate, p_value = test$p.value)
  }
  
  # Perform Spearman correlation and p-value calculation for all combinations of two columns
  for (i in 1:length(taxa)) {
    for (j in i:length(taxa)) {
      if (i == j) {
        correlation_matrix[i, j] <- 1
        p_value_matrix[i, j] <- 0
      } else {
        result <- spearman_test(data_matrix[, i], data_matrix[, j])
        correlation_matrix[i, j] <- result$correlation
        correlation_matrix[j, i] <- result$correlation  # Symmetric matrix
        p_value_matrix[i, j] <- result$p_value
        p_value_matrix[j, i] <- result$p_value  # Symmetric matrix
      }
    }
  }
  return_list <- list(correlation_matrix = correlation_matrix, p_value_matrix = p_value_matrix)
  return(return_list)
}


```

```{r}
heatmap_all_result <- calculate_spearman_correlation(heatmap_all_betas)
heatmap_all_matrix <- heatmap_all_result$correlation_matrix
heatmap_all_pvals <- heatmap_all_result$p_value_matrix

heatmap_urban_result <- calculate_spearman_correlation(heatmap_urban_betas)
heatmap_urban_matrix <- heatmap_urban_result$correlation_matrix
heatmap_urban_pvals <- heatmap_urban_result$p_value_matrix

heatmap_rural_result <- calculate_spearman_correlation(heatmap_rural_betas)
heatmap_rural_matrix <- heatmap_rural_result$correlation_matrix
heatmap_rural_pvals <- heatmap_rural_result$p_value_matrix
```

Narrow down to compare gene expression by microbes of same name

```{r}
calculate_spearman_correlation_between_dfs <- function(df1, df2) {
  # Get the common column names (microbes)
  common_microbes <- intersect(colnames(df1), colnames(df2))
  
  # Initialize vectors to store results
  spearman_correlations <- numeric(length(common_microbes))
  p_values <- numeric(length(common_microbes))
  microbes <- character(length(common_microbes))
  
  # Function to compute Spearman correlation and p-value
  spearman_test <- function(x, y) {
    test <- cor.test(x, y, method = "spearman", use = "pairwise.complete.obs")
    list(correlation = test$estimate, p_value = test$p.value)
  }
  
  # Perform Spearman correlation for each common microbe
  for (i in seq_along(common_microbes)) {
    microbe <- common_microbes[i]
    result <- spearman_test(df1[, microbe], df2[, microbe])
    spearman_correlations[i] <- result$correlation
    p_values[i] <- result$p_value
    microbes[i] <- microbe
  }
  
  # Create a data frame to store the results
  results_df <- data.frame(
    microbe = microbes,
    spearman_correlation = spearman_correlations,
    p_value = p_values
  )
  
  return(results_df)
}

# Example usage
microbe_cors <- calculate_spearman_correlation_between_dfs(heatmap_urban_betas, heatmap_rural_betas) %>%
  mutate(sig = case_when(p_value < 0.1 ~ "sig", T ~ "ns")) %>%
  mutate(lab = case_when(spearman_correlation > 0.15 ~ microbe, 
                         spearman_correlation < -0.15 ~ microbe, 
                         T ~ NA))

```

```{r}
ggplot(microbe_cors, aes(x=microbe, y=spearman_correlation, color=sig)) +
  geom_point() +
  geom_text(aes(label=lab)) 
```

```{r}
# Load necessary library
library(tidyverse)

# Ensure the dataframes have the same row and column names
stopifnot(all(rownames(heatmap_urban_betas) == rownames(heatmap_rural_betas)))
stopifnot(all(colnames(heatmap_urban_betas) == colnames(heatmap_rural_betas)))

heatmap_urban_betas_species <- heatmap_urban_betas %>% dplyr::select(contains("_"))
heatmap_rural_betas_species <- heatmap_rural_betas %>% dplyr::select(contains("_"))

# Initialize a vector to store distances
microbe_distances <- numeric(ncol(heatmap_urban_betas_species))
names(microbe_distances) <- colnames(heatmap_urban_betas_species)

# Calculate Euclidean distances for each microbe
for (microbe in colnames(heatmap_urban_betas_species)) {
  urban_vals <- heatmap_urban_betas[, microbe]
  rural_vals <- heatmap_rural_betas[, microbe]
  microbe_distances[microbe] <- sqrt(sum((urban_vals - rural_vals)^2))
}

# Sort microbes by distance
sorted_microbes <- sort(microbe_distances)

# Most similar microbes (smallest distances)
most_similar_microbes <- head(sorted_microbes, 15)

# Most different microbes (largest distances)
most_different_microbes <- tail(sorted_microbes, 15)

# Print results
cat("Most similar microbes:\n")
print(most_similar_microbes)

cat("\nMost different microbes:\n")
print(most_different_microbes)

```

```{r}
# Load necessary library
library(lsa) # for cosine similarity

# Ensure the dataframes have the same row and column names
stopifnot(all(rownames(heatmap_urban_betas) == rownames(heatmap_rural_betas)))
stopifnot(all(colnames(heatmap_urban_betas) == colnames(heatmap_rural_betas)))

heatmap_urban_betas_species <- heatmap_urban_betas %>% dplyr::select(contains("_"))
heatmap_rural_betas_species <- heatmap_rural_betas %>% dplyr::select(contains("_"))

# Initialize a vector to store similarities
microbe_similarities <- numeric(ncol(heatmap_urban_betas))
names(microbe_similarities) <- colnames(heatmap_urban_betas)

# Calculate cosine similarities for each microbe
for (microbe in colnames(heatmap_urban_betas)) {
  urban_vals <- heatmap_urban_betas[, microbe]
  rural_vals <- heatmap_rural_betas[, microbe]
  microbe_similarities[microbe] <- cosine(urban_vals, rural_vals)
}

# Sort microbes by similarity
sorted_microbes <- sort(microbe_similarities, decreasing = TRUE)

# Most similar microbes (highest similarities)
most_similar_microbes <- head(sorted_microbes, 10)

# Most different microbes (lowest similarities)
most_different_microbes <- tail(sorted_microbes, 10)

# Print results
cat("Most similar microbes:\n")
print(most_similar_microbes)

cat("\nMost different microbes:\n")
print(most_different_microbes)

```


```{r}
sorted_microbes_df <- as.data.frame(sorted_microbes) %>%
  rownames_to_column("taxa") %>%
  left_join(summary_ss_select_urban, by="taxa") %>%
  dplyr::rename(num_genes_urban = num_genes) %>%
  left_join(summary_ss_select_rural, by="taxa") %>%
  dplyr::filter(taxa %in% c("RUG115_sp900066395", "Bariatricus_sp934320645", union(genus001$taxa, species001$taxa))) %>%
  dplyr::rename(num_genes_rural = num_genes) %>%
  mutate(sig_in = case_when(num_genes_urban > 0 & is.na(num_genes_rural) ~ "urban",
                            num_genes_rural > 0 & is.na(num_genes_urban) ~ "rural",
                            num_genes_urban > 0 & num_genes_rural > 0 ~ "both",
                            T ~ "neither"))

sorted_microbes_df_filt <- sorted_microbes_df %>%
  dplyr::filter(!sig_in == "neither") %>%
  dplyr::filter(num_genes_urban > 3 | num_genes_rural > 3)

sorted_microbes_long <- sorted_microbes_df_filt %>%
  pivot_longer(
    cols = c(num_genes_urban, num_genes_rural),
    names_to = "urbanism",
    names_prefix = "num_genes_",
    values_to = "num_genes"
  ) %>%
  mutate(num_genes = case_when(is.na(num_genes) ~ 0,
                               T ~ num_genes)) %>%
  mutate(taxa = str_replace_all(taxa, "_", " "))

sorted_microbes_order <- sorted_microbes_long %>%
  dplyr::filter(urbanism =="rural") %>%
  arrange(num_genes) 

sorted_microbes_long$taxa <- factor(sorted_microbes_long$taxa, levels = unique(sorted_microbes_order$taxa))
```
Update the names... i thought this was updated in the code above?
```{r}
sorted_microbes_long_updated <- sorted_microbes_long %>%
  dplyr::select(urbanism, taxa, num_genes) %>%
  dplyr::mutate(taxa_updated = case_when(taxa == "Dorea sp" ~ "Dorea A longicatena B",
                          taxa == "Roseburia sp 1" ~ "RUG115 sp900066395",
                          taxa == "Clostridium sp 2" ~ "Bariatricus sp934320645",
                          taxa == "Coprococcus sp" ~ "Coprococcus eutactus A",
                         T ~ taxa))

sorted_microbes_order_updated <- sorted_microbes_long_updated %>%
  dplyr::filter(urbanism =="rural") %>%
  arrange(num_genes) 

sorted_microbes_long_updated$taxa_updated <- factor(sorted_microbes_long_updated$taxa_updated, levels = unique(sorted_microbes_order_updated$taxa_updated))
```

```{r}
ggplot(sorted_microbes_long_updated, aes(x=urbanism, y=taxa_updated, fill=urbanism, alpha=num_genes)) +
  geom_tile() +
  scale_fill_manual(values=c("#6FBD8B", "#7B2BC1")) +
  theme_linedraw() +
  theme(axis.text.y = element_text(face = "italic"),
        panel.grid.major = element_blank(),  # Remove major gridlines
        panel.grid.minor = element_blank())  # Remove minor gridlines
ggsave("results/figs/RNAseq-metaG-microbe-Lasso/top_microbes.png", width = 3.7, height=2.5)
```

Replace NS with 0 in correlation matrix

```{r}
replace_non_significant <- function(correlation_matrix, p_value_matrix, significance_level) {
  # Create a copy of the correlation matrix to modify
  significant_correlation_matrix <- correlation_matrix
  
  # Find the indices of non-significant p-values
  non_significant_indices <- which(p_value_matrix >= significance_level, arr.ind = TRUE)
  
  # Replace the corresponding values in the correlation matrix with 0
  significant_correlation_matrix[non_significant_indices] <- 0
  
  return(significant_correlation_matrix)
}
```

Long

```{r}
heatmap_long <- function(significant_correlation_matrix) {
  significant_correlation_matrix <- 
    as.data.frame(significant_correlation_matrix) %>%
    rownames_to_column("taxa1") %>%
    pivot_longer(-taxa1, names_to = "taxa2", values_to = "correlation")
  return(significant_correlation_matrix)
}
```

```{r}
heatmap_all_sig <- replace_non_significant(heatmap_all_matrix, heatmap_all_pvals, 0.1)
heatmap_all_sig_long <- heatmap_long(heatmap_all_sig)
heatmap_urban_sig <- replace_non_significant(heatmap_urban_matrix, heatmap_urban_pvals, 0.1)
heatmap_urban_sig_long <- heatmap_long(heatmap_urban_sig)
heatmap_rural_sig <- replace_non_significant(heatmap_rural_matrix, heatmap_rural_pvals, 0.1)
heatmap_rural_sig_long <- heatmap_long(heatmap_rural_sig)
```

Function to save heatmap

```{r}
save_pheatmap_png <- function(x, filename, width=800, height=600, res = 150) {
  png(filename, width = width, height = height, res = res)
  grid::grid.newpage()
  grid::grid.draw(x$gtable)
  dev.off()
}
```

Get information about differential abundance OR food group ownership

```{r}
heatamp_aldex2_clr_all_sig <- aldex2_clr_all_sig %>%
  dplyr::filter(taxa %in% union_sigtaxa)

# Create annotation data frame for rows (taxa)
#annotation_df <- data.frame(DA_urbanism = heatamp_aldex2_clr_all_sig$DA_urbanism)
#rownames(annotation_df) <- heatamp_aldex2_clr_all_sig$taxa

food_clusters <- read.csv("results/docs/food_clusters.csv", row.names=1)
annotation_df <- data.frame(food_group = food_clusters$food_group)
rownames(annotation_df) <- food_clusters$taxa

# Initialize annotation for all taxa as NA
#annotation_row <- data.frame(DA_urbanism = rep(NA, nrow(heatmap_rural_sig)))
#rownames(annotation_row) <- rownames(heatmap_rural_sig)

annotation_row <- data.frame(food_group = rep(NA, nrow(heatmap_rural_sig)))
rownames(annotation_row) <- rownames(heatmap_rural_sig)

# Update the annotation for the taxa present in heatamp_aldex2_clr_all_sig
common_taxa <- intersect(rownames(annotation_row), rownames(annotation_df))
annotation_row[common_taxa, ] <- annotation_df[common_taxa, ]

# Define colors for annotations
annotation_colors <- list(
  #DA_urbanism = c(rural = "#6FBD8B", urban = "#7B2BC1")
  food_group = c("red", "blue")
)

```

```{r}
save_pheatmap_png(urban_heatmap, "results/figs/RNAseq-metaG-microbe-Lasso/urban_heatmap.png")
save_pheatmap_png(rural_heatmap, "results/figs/RNAseq-metaG-microbe-Lasso/rural_heatmap.png")
```

Import correlation of microbe abundances to lifestyle

```{r}
microbe_PC1_results <- read.csv("results/docs/microbe_PC1_results.csv", row.names=1)
head(microbe_PC1_results)
```

```{r}
library(lsa)   # for cosine similarity

# Extract columns containing underscores
heatmap_all_betas_species <- heatmap_all_betas %>% dplyr::select(contains("_"))

# Initialize matrices to store similarities and significance
n <- ncol(heatmap_all_betas_species)
similarity_matrix <- matrix(0, nrow = n, ncol = n)
significance_matrix <- matrix(NA, nrow = n, ncol = n)
rownames(similarity_matrix) <- colnames(heatmap_all_betas_species)
colnames(similarity_matrix) <- colnames(heatmap_all_betas_species)
rownames(significance_matrix) <- colnames(heatmap_all_betas_species)
colnames(significance_matrix) <- colnames(heatmap_all_betas_species)

# Calculate pairwise cosine similarities
for (i in 1:n) {
  for (j in 1:n) {
    vec_i <- heatmap_all_betas_species[, i]
    vec_j <- heatmap_all_betas_species[, j]
    
    similarity_matrix[i, j] <- cosine(vec_i, vec_j)
  }
}

# Example permutation test function (for illustration purposes)
perm_test <- function(vec1, vec2, num_permutations = 1000) {
  observed_sim <- cosine(vec1, vec2)
  permuted_sims <- numeric(num_permutations)
  
  for (k in 1:num_permutations) {
    permuted_vec1 <- sample(vec1)
    permuted_sims[k] <- cosine(permuted_vec1, vec2)
  }
  
  p_value <- mean(permuted_sims >= observed_sim)
  return(p_value)
}

# Calculate p-values for each pairwise comparison
for (i in 1:n) {
  for (j in 1:n) {
    vec_i <- heatmap_all_betas_species[, i]
    vec_j <- heatmap_all_betas_species[, j]
    
    significance_matrix[i, j] <- perm_test(vec_i, vec_j)
  }
}
```

```{r}
library(igraph)
library(TeachingDemos)

make_network <- function(cor_matrix, lb, ub) {
  
  ##HACK TO GET SPEICES
 # Filter rows with underscore in their names
cor_matrix <- cor_matrix[grepl("_", rownames(cor_matrix)), ]

# Filter columns with underscore in their names
cor_matrix <- cor_matrix[, grepl("_", colnames(cor_matrix))]

# Keep only high correlations
mat <- cor_matrix
mat[mat > lb & mat < ub] <- 0
mat[mat == 1] <- 0

# Remove rows that are all zeros
mat <- mat[rowSums(mat != 0) > 0, ]

# Remove columns that are all zeros
mat <- mat[, colSums(mat != 0) > 0]
 
# Make an Igraph object from this matrix:
network <- graph_from_adjacency_matrix(mat, weighted=T, mode="undirected", diag=F)

# Calculate vertex degree or centrality (e.g., degree centrality)
vertex_degrees <- degree(network)

# Normalize vertex degrees for label size
vertex_label_sizes <- (vertex_degrees - min(vertex_degrees)) / (max(vertex_degrees) - min(vertex_degrees)) * 1.2 + 1

# Edge widths
min_width <- 2  # Minimum edge width
mat_abs <- abs(mat)
edge_widths <- mat_abs[lower.tri(mat_abs)] * 10 + min_width

# Edge colors (positive vs. negative correaltion)
edge_colors <- ifelse(mat < 0, "red", "grey")

# Fix string in species names
node_labels <- V(network)$name
#  for (i in seq_along(node_labels)) {
#    node_labels[i] <- sub("_", "\n", node_labels[i], fixed = TRUE) }

 #Green if enriched in rural, purple if enriched in urban
#node_colors <- case_when(
#  rownames(mat) %in% aldex2_clr_all_sig$taxa[aldex2_clr_all_sig$DA_urbanism == "rural"] ~ "#6FBD8B",
#  rownames(mat) %in% aldex2_clr_all_sig$taxa[aldex2_clr_all_sig$DA_urbanism == "urban"] ~ "#7B2BC1",
#  TRUE ~ "gray10"
#)

# Create a color gradient for node colors based on correlations
  #color_palette <- colorRampPalette(brewer.pal(n = 5, name = "YlGnBu"))  # Red to White to Blue
color_palette <- colorRampPalette(brewer.pal(n = 5, name = "BrBG"))
  correlation_values <- microbe_PC1_results$Correlation[match(node_labels, microbe_PC1_results$taxa)]
  node_colors <- color_palette(100)[as.numeric(cut(correlation_values, breaks = 100))]


# Basic chart
plot(network, 
     vertex.size=5,
     vertex.label = node_labels,
     vertex.label.cex=vertex_label_sizes,
     #edge.width=edge_widths,
     edge.color=edge_colors,
     layout=layout_nicely(network),  # Arrange nodes nicely
     vertex.label.color=node_colors,  # Use node_colors for text color
     #vertex.label.color="black",
     vertex.color=node_colors,
     #vertex.shape="none",
     vertex.label.family = "Arial",
     vertex.label.font = 4,  
     vertex.label.dist=0.25)

}


```

```{r}
#make_network(heatmap_rural_sig, -0.5, 0.5)
#make_network(heatmap_urban_sig, -0.5, 0.5)
make_network(heatmap_all_sig, -0.5, 0.5)
```

```{r}
png("results/figs/RNAseq-metaG-microbe-Lasso/network_rural.png", width=800, height=800)
network_rural <- make_network(heatmap_rural_sig, -0.4, 0.4)
dev.off()

png("results/figs/RNAseq-metaG-microbe-Lasso/network_urban.png", width=1300, height=1300)  # Adjust width and height as needed
network_urban <- make_network(heatmap_urban_sig, -0.4, 0.4)
dev.off()

png("results/figs/RNAseq-metaG-microbe-Lasso/network_all.png", width=1300, height=1300)  # Adjust width and height as needed
network_all <- make_network(heatmap_all_sig, -0.4, 0.4)
dev.off()

png("results/figs/RNAseq-metaG-microbe-Lasso/network_all_COSINE.png", width=1300, height=1300)  # Adjust width and height as needed
network_all <- make_network(similarity_matrix, -0.4, 0.4)
dev.off()
```

```{r}
make_network3 <- function(df, taxa_summary, gene_summary) {
  
  top_taxa <- taxa_summary %>%
    dplyr::filter(num_genes > 0)
  
  top_genes <- gene_summary %>%
    dplyr::filter(num_taxa > 3)
  
  edge_list <- df %>%
     dplyr::select(gene, taxa, beta_est) %>%
    dplyr::filter(abs(beta_est) > 0.03)
 
# Make an Igraph object from this matrix:
network <- graph_from_data_frame(d = edge_list, directed = FALSE)

# Calculate vertex degree or centrality (e.g., degree centrality)
  vertex_degrees <- degree(network)
  
  # Normalize vertex degrees for label size
  vertex_label_sizes <- (vertex_degrees - min(vertex_degrees)) / (max(vertex_degrees) - min(vertex_degrees)) * 1.2 + 1
  
  # Edge widths
  edge_widths <- E(network)$beta_est * 10 + 3
  
  # Edge colors (positive vs. negative correlation)
  edge_colors <- ifelse(E(network)$beta_est < 0, "blue", "orange")
  
  # Fix string in species names
  node_labels <- ifelse(V(network)$name %in% union(top_genes$gene, top_taxa$taxa), V(network)$name, NA)
  
  #node_labels <- sub("_", "\n", node_labels, fixed = TRUE)
  
  # Green if enriched in rural, purple if enriched in urban
  label_colors <- case_when(
    V(network)$name %in% aldex2_clr_all_sig$taxa[aldex2_clr_all_sig$DA_urbanism == "rural"] ~ "#6FBD8B",
    V(network)$name %in% aldex2_clr_all_sig$taxa[aldex2_clr_all_sig$DA_urbanism == "urban"] ~ "#7B2BC1",
    TRUE ~ "gray10"
  )
  
  vertex_colors <- case_when(
    V(network)$name %in% edge_list$taxa ~ "red",
    V(network)$name %in% edge_list$gene ~ "black",
    TRUE ~ "gray10"
  )
  
  node.size= c(10,10,10)

# Basic chart
plot(network, 
     # label
     vertex.label=node_labels, 
     vertex.label.color=label_colors,
    vertex.label.family = "Arial",
     vertex.label.font = 3,
     vertex.label.dist=0.25,
    # vertex
     vertex.size=1,
    vertex.colors=vertex_colors,
    # edges
     edge.width=edge_widths,
     edge.color="grey",
    #layout
    layout=layout.auto
)
}

```

```{r}
make_network3(lasso_all_select, summary_ss_select_all, genesummary_ss_select_all)
#make_network3(lasso_rural_select, summary_ss_select_rural, genesummary_ss_select_rural)
#make_network3(lasso_urban_select, summary_ss_select_urban, genesummary_ss_select_urban)
```

```{r}
png("../../../Downloads/pic1.png", width=800, height=800)
make_network3(lasso_all_select, summary_ss_select_all, genesummary_ss_select_all)
dev.off()
```
