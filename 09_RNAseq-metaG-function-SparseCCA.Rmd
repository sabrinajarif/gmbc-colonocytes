---
title: "R Notebook"
output: html_notebook
---

```{r}
library(ggplot2)
library(tidyverse)
library(biomaRt)
library(clusterProfiler)
library(ReactomePA)
library(limma)
library(DESeq2)
```

Tutorial
This tutorial demonstrates integration methods used for joint analysis of host transcriptomic and microbiome data as described in Priya et al. "Shared and disease-specific host gene-microbiome associations across human diseases".

1. Sparse CCA
Sparse Canonical Correlation Analysis (sparse CCA) identifies linear combination of subsets of variables from two datasets such that they are maximally correlated (Witten et al. 2009). We will apply this approach to identify groups of host genes that are associated with groups of microbial taxa.

Setting up input and output
Download the folder sparseCCA_tutorial at a relevant location on your computer. This folder includes the Rscript sparseCCA_tutorial.R with all functions used in sparse CCA tutorial, an input folder with demo dataset (i.e. gene_expresion_demo_sp_CCA.txt and microbiome_demo_sp_CCA.txt), and an output folder. Open and execute the script sparseCCA_tutorial.R to load all libraries and functions, and follow the steps below.

Step 1: Read input data

```{r}
## In Rstudio, find the path to the directory where the current script is located.
## If not using Rstudio, current_dir should point to your working directory for this demo.
current_dir <- dirname(rstudioapi::getSourceEditorContext()$path)
```
```{r}
meta <- read.csv(paste0(current_dir,"/data/metadata/meta_RNAseq.csv"), row.names = 1) %>%
  # Batch as character
  mutate(Batch = as.character(Batch)) %>%
  # exclude controls
  dplyr::filter(!Luca_Lab_ID=="control") %>%
  # This sample was bad quality 
  dplyr::filter(!SampleID %in% c("GMCC1S1")) %>%
  # These samples were outliers amongst the RNAseq
  dplyr::filter(!SampleID %in% c("GMCC4S10", "GMCC3S7", "GMCC4C6", "GMCC5C5", "GMCC5C4", "GMCC5C3")) %>%
  # These samples were not used to treat the colonocytes
  dplyr::filter(!SampleName %in% c("1127XT", "1462QI", "3364PX", "3553XK", "3606IJ", "9423WC")) %>%
  # These samples did not have metagenomic sequencing data
  dplyr::filter(!SampleID %in% c("GMCC1S6", "GMCC2S3", "GMCC4S7")) %>%
  # This sample is missing from function data
  dplyr::filter(!SampleID =="GMCC5S12") %>%
  mutate(rn = SampleID) %>%
  column_to_rownames("rn") 
  #dplyr::filter(!SampleName=="4342XH")
meta <- meta[order(row.names(meta)), ]

meta_urban <- meta %>% dplyr::filter(urbanism=="urban")
meta_urban <- meta_urban[order(row.names(meta_urban)), ]

meta_rural <- meta %>% dplyr::filter(urbanism=="rural")
meta_rural <- meta_rural[order(row.names(meta_rural)), ]

```
```{r}
## load gene expression data
# samples are rows, genes are columns
#genes <- load_gene_expr(paste0(current_dir,"/input/gene_expresion_demo_sp_CCA.txt"))
genes <- read.csv(paste0(current_dir,"/results/docs/raw_read_cts_filt.csv"), row.names = 1)
genes <- genes[, colnames(genes) %in% meta$SampleID] 
genes <- genes[, !colnames(genes) %in% "GMCC5S12"] #this sample is missing from function data
genes <- genes[, order(colnames(genes))] %>% t() %>% as.matrix()
```
```{r}
genes_urban <- genes[rownames(genes) %in% meta_urban$SampleID, ]
genes_urban <- genes_urban[order(rownames(genes_urban)),]

genes_rural <- genes[rownames(genes) %in% meta_rural$SampleID, ]
genes_rural <- genes_rural[order(rownames(genes_rural)),]
```
Perform batch correction
```{r}
genes_bc <- removeBatchEffect(t(genes), c(meta$Batch)) 
```
Apply variance stabilizing transformation from DESeq2
```{r}
dds <- DESeqDataSetFromMatrix(countData = t(genes), 
                              colData = meta, 
                              design = ~ 1) 

# Normalize the counts
dds <- estimateSizeFactors(dds)
normalized_counts <- counts(dds, normalized=TRUE)

vsd <- vst(dds, blind = FALSE)

normalized_counts_bc <- removeBatchEffect(normalized_counts, c(meta$Batch)) 
# set negative values to 0
normalized_counts_bc[normalized_counts_bc < 0] <- 0
# round the values to the nearest integer
normalized_counts_bc <- round(normalized_counts_bc)


dds_bc <- DESeqDataSetFromMatrix(countData = normalized_counts_bc, 
                                 colData = meta, 
                                 design = ~ 1)

vsd_bc <- vst(dds_bc, blind = FALSE)
vsd_mat <- assay(vsd_bc)

# Filter out genes with low variance using 25% quantile as cut-off for each disease cohort
# Assuming 'meta' contains a column 'disease_cohort' that specifies the disease cohort for each sample
# Adjust the column name 'disease_cohort' to the actual column name in your metadata

filtered_genes_list <- lapply(unique(meta$urbanism), function(cohort) {
  # Subset the transformed matrix and metadata for the current cohort
  cohort_samples <- meta %>% dplyr::filter(urbanism == cohort) %>% rownames()
  cohort_vsd_mat <- vsd_mat[, cohort_samples]
  
  # Calculate variance for each gene in the current cohort
  gene_variances <- apply(cohort_vsd_mat, 1, var)
  
  # Determine the 25% quantile of variance
  variance_cutoff <- quantile(gene_variances, 0.25)
  
  # Filter genes with variance above the 25% quantile
  filtered_genes <- rownames(cohort_vsd_mat)[gene_variances > variance_cutoff]
  
  return(filtered_genes)
})

# Combine the filtered gene lists from each cohort
filtered_genes <- unique(unlist(filtered_genes_list))

# Subset the transformed matrix to include only the filtered genes
genes_bc_vst_varfilt <- vsd_mat[filtered_genes, ]

# Check the dimensions of the filtered matrix
dim(genes_bc_vst_varfilt)

genes_bc_vst_varfilt <- t(genes_bc_vst_varfilt)
```
```{r}
plotPCA(vsd, intgroup = "Batch")
plotPCA(vsd_bc, intgroup = "Batch")
```
```{r}
genes_urban <- genes_bc_vst_varfilt[rownames(genes_bc_vst_varfilt) %in% meta_urban$SampleID, ]
genes_urban <- genes_urban[order(rownames(genes_urban)),]

genes_rural <- genes_bc_vst_varfilt[rownames(genes_bc_vst_varfilt) %in% meta_rural$SampleID, ]
genes_rural <- genes_rural[order(rownames(genes_rural)),]
```



```{r}
## load microbiome data
# samples are rows, individual taxa are columns
# column names are like this: 
# Bacteria;Bacteroidetes;Bacteroidia;Bacteroidales;Prevotellaceae

pathways <- read.csv(paste0(current_dir,"/results/docs/clr_filt_function_abundances.csv"), check.names=F, row.names = 1) %>%
  t() %>%
  as.data.frame() 
pathways <- pathways %>%
  dplyr::mutate(SampleName = row.names(pathways)) %>%
  left_join(meta[c("SampleName", "SampleID")],by="SampleName") %>%
  dplyr::filter(SampleID %in% meta$SampleID) %>%
  dplyr::select(-SampleName) %>%
  column_to_rownames("SampleID") %>%
  as.matrix()
pathways <- pathways[order(rownames(pathways)),] 

pathways_urban <- pathways[rownames(pathways) %in% meta_urban$SampleID, ]
pathways_urban <- pathways_urban[order(rownames(pathways_urban)),]

pathways_rural <- pathways[rownames(pathways) %in% meta_rural$SampleID, ]
pathways_rural <- pathways_rural[order(rownames(pathways_rural)),]

## Ensure same samples in both genes and microbes data
stopifnot(all(rownames(genes) == rownames(pathways)))
setdiff(rownames(genes), rownames(pathways))
```

Step 2: Tune hyperparameters

Sparsity penalties control the amount of sparsity in the gut microbiome data and gene expression data. The sparsity penalty encourages the model to select only a subset of the most important features and set the others to zero. It reduces overfitting by penalizing the inclusion of too many features, increases interperetability by simplifying the model, increases efficiency, and limits redundancy among highly correlated features. Higher values of bestpenaltyX and Y result in sparser loading vectors (fewer features are considered in correlation analysis).

This step uses grid-search that takes a while to run, so we've pre-computed penalty values for the demo dataset that you can set as follows, and skip to Step 3.
```{r}
tune_params_grid_search_modified <- function(X, Y){
  
  penaltyX <- seq(0.05, 0.4, length = 10)
  penaltyY <- seq(0.05, 0.4, length = 10)
  corr_demo <- matrix(nrow = length(penaltyX), ncol = length(penaltyY))
  num_samples <- nrow(X)
  start_time <- Sys.time()
  
  for(i in 1:length(penaltyX)){
    for(j in 1:length(penaltyY)){
      scoreXcv <- numeric(num_samples)
      scoreYcv <- numeric(num_samples)
      
      for(k in 1:num_samples){
        print(paste0("Index: i = ", i, ", j = ", j, " k = ", k))
        flush.console()
        
        # Compute weights with sample k held out:
        # Default niter = 15 edited to 5 to speed this up.
        res <- CCA(X[-k,], Y[-k,], penaltyx = penaltyX[i], penaltyz = penaltyY[j], K = 1, niter = 5, trace = F, standardize = T)
        
        # Compute scores for k'th sample for first pair of canonical variables
        scoreXcv[k] <- X[k,] %*% res$u # single value
        scoreYcv[k] <- Y[k,] %*% res$v # single value
      }
      
      # Correlation between scores for X and Y for all held out samples.
      corr_demo[i, j] = cor(scoreXcv, scoreYcv)
    }
  }
  
  end_time <- Sys.time()
  time_elapsed <- end_time - start_time
  print(paste0("Time elapsed for param tuning = ", time_elapsed))
  flush.console()
  
  row.names(corr_demo) <- as.character(penaltyX)
  colnames(corr_demo) <- as.character(penaltyY)
  
  corr_demo_df <- as.data.frame(corr_demo)
  
  # Identify best penalty parameters
  bestpenalty <- which(abs(corr_demo) == max(abs(corr_demo)), arr.ind = TRUE)
  bestpenaltyX <- penaltyX[bestpenalty[1]]
  bestpenaltyY <- penaltyY[bestpenalty[2]]
  
  return(c(bestpenaltyX, bestpenaltyY))
}


```

```{r}
## Skip to Step 3 if using pre-computed values above
## select tuning parameters using grid-search
#bestPenalty_urban <- tune_params_grid_search_modified(genes_urban,pathways_urban)
#bestpenaltyX_urban <- bestPenalty_urban[1]
#bestpenaltyY_urban <- bestPenalty_urban[2]
#bestpenaltyX_urban <- 0.3222222 #GENES
#bestpenaltyY_urban <- 0.05 #PATHWAYS
```
```{r}
#bestPenalty_rural <- tune_params_grid_search_modified(genes_rural,pathways_rural)
#bestpenaltyX_rural <- bestPenalty_rural[1]
#bestpenaltyY_rural <- bestPenalty_rural[2]
#bestpenaltyX_rural <- 0.05 #GENES
#bestpenaltyY_rural <- 0.3222222 #PATHWAYS 
```
```{r}
bestpenaltyX_urban <- 0.1 #GENES
bestpenaltyY_urban <- 0.07 #PATHWAYS

bestpenaltyX_rural <- 0.1 #GENES
bestpenaltyY_rural <- 0.07 #PATHWAYS 
```

Step 3: Run sparse CCA
```{r}
## Set the number of desired CCA components
cca.k = 10

## run sparse CCA
#cca_all <- run_sparseCCA(genes, pathways, cca.k, bestpenaltyX, bestpenaltyY,
#                     outputFile=paste0(current_dir,"/results/docs/CCA/functions/CCA_all_output_",bestpenaltyX,"_",bestpenaltyY,".txt"))

cca_urban <- run_sparseCCA(genes_urban, pathways_urban, cca.k, bestpenaltyX_urban, bestpenaltyY_urban,
                     outputFile=paste0(current_dir,"/results/docs/CCA/functions/CCA_urban_output_",bestpenaltyX_urban,"_",bestpenaltyY_urban,".txt"))

cca_rural <- run_sparseCCA(genes_rural, pathways_rural, cca.k, bestpenaltyX_rural, bestpenaltyY_rural,
                     outputFile=paste0(current_dir,"/results/docs/CCA/functions/CCA_rural_output_",bestpenaltyX_rural,"_",bestpenaltyY_rural,".txt"))

```
```{r}
## average number of genes and microbes in resulting components
#avg_genes_all <- get_avg_features(cca_all[[1]]$u, cca.k)
avg_genes_urban <- get_avg_features(cca_urban[[1]]$u, cca.k)
avg_genes_rural <- get_avg_features(cca_rural[[1]]$u, cca.k)
#avg_genes_all
avg_genes_urban
avg_genes_rural
```
```{r}
#avg.pathways_all <- get_avg_features(cca_all[[1]]$v, cca.k)
avg.pathways_urban <- get_avg_features(cca_urban[[1]]$v, cca.k)
avg.pathways_rural <- get_avg_features(cca_rural[[1]]$v, cca.k)
#avg.pathways_all
avg.pathways_urban
avg.pathways_rural
```


Output is a text file that looks like this:

Call: CCA(x = X, z = Z, typex = "standard", typez = "standard", penaltyx = penaltyX, 
    penaltyz = penaltyZ, K = CCA.K, v = vInit)


Num non-zeros u's:  56 52 56 58 85 129 304 477 604 563 
Num non-zeros v's:  42 36 33 37 45 38 40 45 41 43 
Type of x:  standard 
Type of z:  standard 
Penalty for x: L1 bound is  0.05 
Penalty for z: L1 bound is  0.3222 
Cor(Xu,Zv):  0.9073038 0.9204368 0.9055074 0.9295641 0.8482518 0.8713182 0.9100314 0.816952 0.9080543 0.8389779

Step 4: Test significance of components using leave-one-out cross-validation
```{r}
## This will take ~1 min to run. 
#CCA_pval_all <- test_significance_LOOCV(genes, pathways, bestpenaltyX, bestpenaltyY, cca.k)
CCA_pval_urban <- test_significance_LOOCV(genes_urban, pathways_urban, bestpenaltyX_urban, bestpenaltyY_urban, cca.k)
CCA_pval_rural <- test_significance_LOOCV(genes_rural, pathways_rural, bestpenaltyX_rural, bestpenaltyY_rural, cca.k)

## adjust for multiple testing
#CCA_padj_all <- p.adjust(CCA_pval_all, method = "BH")
CCA_padj_urban <- p.adjust(CCA_pval_urban, method = "BH")
CCA_padj_rural <- p.adjust(CCA_pval_rural, method = "BH")
```
Step 5. Output significant components
```{r}
sig_cutoff <- 0.1 
#sig_all <- which(CCA_padj_all < sig_cutoff)
#ns_all <- which(CCA_padj_all > sig_cutoff)
sig_urban <- which(CCA_padj_urban < sig_cutoff)
ns_urban <- which(CCA_padj_urban > sig_cutoff)
sig_rural <- which(CCA_padj_rural < sig_cutoff)
ns_rural <- which(CCA_padj_rural > sig_cutoff)

#dirname_all <- paste0(current_dir,"/results/docs/CCA/functions/CCA_all_gene_function_components_",bestpenaltyX,"_",bestpenaltyY,"/")
dirname_urban <- paste0(current_dir,"/results/docs/CCA/functions/CCA_urban_gene_taxa_components_",bestpenaltyX_urban,"_",bestpenaltyY_urban,"/")
dirname_rural <- paste0(current_dir,"/results/docs/CCA/functions/CCA_rural_gene_taxa_components_",bestpenaltyX_rural,"_",bestpenaltyY_rural,"/")
## This returns returns true if directory didn't exist but was successfully created,
## and returns false if the directory already exists or can't be created.

#ifelse(!dir.exists(dirname_all), dir.create(dirname_all), FALSE)
ifelse(!dir.exists(dirname_urban), dir.create(dirname_urban), FALSE)
ifelse(!dir.exists(dirname_rural), dir.create(dirname_rural), FALSE)

#save_CCA_components(cca_all[[1]],sig_all,dirname_all)
save_CCA_components(cca_urban[[1]],sig_urban,dirname_urban)
save_CCA_components(cca_rural[[1]],sig_rural,dirname_rural)
```

Each sparse CCA component includes non-zero weights (or canonical loadings) on gut microbes, and non-zero weights on a subset of host genes correlated with those gut microbes to capture joint variation in the two sets of observations. In the 2022 paper, we computed the first 10 sparse CCA components for each disease cohort, performing a separate computation for case and control samples. Sparse CCA components were computed iteratively, informed by previously computed components, thus resulting in uncorrelated components

Example of output of first component:

""	"gene"	"gene_coeff"	"taxa"	"taxa_coeff"
"1"	"GFPT2"	"-0.254431304769467"	"Bacteria;Actinobacteria;Actinobacteria;Actinomycetales;Cellulomonadaceae"	"0.0249812131347486"
"2"	"G0S2"	"-0.137297666144613"	"Bacteria;Actinobacteria;Coriobacteriia;Coriobacteriales;Coriobacteriaceae;Collinsella"	"-0.0148244930560778"
"3"	"AVPR1A"	"-0.171512958610656"	"Bacteria;Actinobacteria;Coriobacteriia;Coriobacteriales;Coriobacteriaceae;Collinsella;aerofaciens"	"-0.0188094005428207"
"4"	"SPON1"	"-0.0105963094345551"	"Bacteria;Actinobacteria;Coriobacteriia;Coriobacteriales;Coriobacteriaceae;Eggerthella;lenta"	"-0.129269896938538"
"5"	"PTX3"	"-0.0165080949973823"	"Bacteria;Bacteroidetes"	"-0.282670982390855"
"6"	"ADAMTS4"	"-0.0709393594399653"	"Bacteria;Bacteroidetes;Bacteroidia;Bacteroidales"	"-0.300058186797506"

For further processing to visualize sparse CCA components, perform enrichment analysis on selected genes, etc., please check here.



- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
ANALYSIS

Obtain names of bacteria and genes associated with each cluster
```{r}
save_CCA_components_env <- function(CCA.out, CCA.K){
  result_list <- list()  # Initialize an empty list to store data frames
  ## Print canonical covariates in files 
  for(i in CCA.K){
    print(paste0("Writing significant component = ", i))
    selected_X <- which(CCA.out$u[,i]!=0) 
    selected_X <- rownames(CCA.out$u)[selected_X]
    coeff_X <- unname(CCA.out$u[selected_X,i])
    selected_Z <- which(CCA.out$v[,i]!=0)
    selected_Z <- rownames(CCA.out$v)[selected_Z]
    coeff_Z <- unname(CCA.out$v[selected_Z,i])
    ## Make all vectors of same length to avoid repetition of elements from shorter vectors.
    n <- max(length(selected_X), length(selected_Z))
    length(selected_X) <- n                      
    length(selected_Z) <- n
    length(coeff_X) <- n
    length(coeff_Z) <- n
    selected_XZ <- as.data.frame(cbind(gene = selected_X, gene_coeff = coeff_X,
                                       functions = selected_Z, functions_coeff = coeff_Z)) 
    result_list[[paste0("component_", i)]] <- selected_XZ  # Append data frame to the list
  }
  return(result_list)
}
```

```{r}
# nested list of genes and microbes
#sig_all_df <- save_CCA_components_env(cca_all[[1]],sig_all)
sig_urban_df <- save_CCA_components_env(cca_urban[[1]],sig_urban)
sig_rural_df <- save_CCA_components_env(cca_rural[[1]],sig_rural)

# microbes only
#sig_all_functions <- lapply(sig_all_df, function(df) na.omit(df$functions))
sig_urban_pathways <- lapply(sig_urban_df, function(df) na.omit(df$functions))
sig_rural_pathways <- lapply(sig_rural_df, function(df) na.omit(df$functions))

# genes only
#sig_all_genes <- lapply(sig_all_df, function(df) df$gene)
sig_urban_genes <- lapply(sig_urban_df, function(df) df$gene)
sig_rural_genes <- lapply(sig_rural_df, function(df) df$gene)
```
Curious which were not significant
```{r}
#ns_all_df <- save_CCA_components_env(cca_all[[1]],ns_all)
ns_urban_df <- save_CCA_components_env(cca_urban[[1]],ns_urban)
ns_rural_df <- save_CCA_components_env(cca_rural[[1]],ns_rural)

ns_urban_microbes <- lapply(ns_urban_df, function(df) na.omit(df$functions))
ns_rural_microbes <- lapply(ns_rural_df, function(df) na.omit(df$functions))

```
Save for downstream use
```{r}
CCA_microbe_elements <- list(genes = genes,
                          genes_urban = genes_urban, 
                          genes_rural = genes_rural, 
                         #sig_all_df = sig_all_df,
                          sig_urban_df = sig_urban_df, 
                          sig_rural_df = sig_rural_df, 
                         #sig_all_functions = sig_all_functions,
                          sig_urban_pathways = sig_urban_pathways,
                          sig_rural_pathways = sig_rural_pathways,
                         #sig_all_genes = sig_all_genes)
                          sig_urban_genes = sig_urban_genes, 
                          sig_rural_genes = sig_rural_genes)
saveRDS(CCA_microbe_elements, "results/rds/CCA_microbe_elements_function.rds")
#saveRDS(CCA_microbe_elements, "results/rds/CCA_function_elements_all.rds")
```
```{r}
# Remove all objects from the environment
rm(list = ls())

# Garbage collect to free up memory
gc()

```

